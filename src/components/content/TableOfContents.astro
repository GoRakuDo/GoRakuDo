---
export interface Props {
  headings?: { depth: number; slug: string; text: string }[]
}

const { headings = [] } = Astro.props
---

{headings.length > 0 && (
  <>
    <aside class="toc-container" aria-label="Table of Contents">
      <div class="toc-header">
        <h2 class="toc-title">
          Daftar isi:
        </h2>
        <button class="toc-toggle" aria-label="Hide table of contents" aria-expanded="true" data-state="visible">
          <svg 
            class="toc-hide-icon"
            width="20" 
            height="20" 
            viewBox="0 0 24 24" 
            fill="none" 
            stroke="var(--token-purple-base)" 
            stroke-width="2" 
            stroke-linecap="round" 
            stroke-linejoin="round"
          >
            <rect width="18" height="18" x="3" y="3" rx="2"/>
            <path d="M8 12h8"/>
          </svg>
          <svg 
            class="toc-show-icon"
            width="16" 
            height="16" 
            viewBox="0 0 24 24" 
            fill="none" 
            stroke="currentColor" 
            stroke-width="2" 
            stroke-linecap="round" 
            stroke-linejoin="round"
          >
            <line x1="8" y1="6" x2="21" y2="6"></line>
            <line x1="8" y1="12" x2="21" y2="12"></line>
            <line x1="8" y1="18" x2="21" y2="18"></line>
            <line x1="3" y1="6" x2="3.01" y2="6"></line>
            <line x1="3" y1="12" x2="3.01" y2="12"></line>
            <line x1="3" y1="18" x2="3.01" y2="18"></line>
          </svg>
        </button>
      </div>
      <nav class="toc-nav" role="navigation" aria-label="Table of contents navigation">
        <ol class="toc-list">
          {headings.map((heading) => (
            <li class={`toc-item toc-level-${heading.depth}`}> 
              <a 
                href={`#${heading.slug}`} 
                class="toc-link"
                data-heading-id={heading.slug}
              >
                {heading.text}
              </a>
            </li>
          ))}
        </ol>
      </nav>
      
      <!-- Mobile TOC Footer - Only visible on mobile -->
      <div class="toc-footer">
        <button class="toc-expand-toggle" aria-label="Expand table of contents" aria-expanded="false">
          <span class="toc-expand-text">Tampilkan Daftar isi</span>
          <svg 
            class="toc-expand-icon"
            xmlns="http://www.w3.org/2000/svg" 
            width="24" 
            height="24" 
            viewBox="0 0 24 24" 
            fill="none" 
            stroke="currentColor" 
            stroke-width="2" 
            stroke-linecap="round" 
            stroke-linejoin="round"
          >
            <path d="m7 6 5 5 5-5"/>
            <path d="m7 13 5 5 5-5"/>
          </svg>
        </button>
      </div>
    </aside>

    <!-- Floating toggle button for when TOC is hidden -->
    <button class="toc-floating-toggle" aria-label="Show table of contents" style="display: none;">
      <svg 
        width="20" 
        height="20" 
        viewBox="0 0 24 24" 
        fill="none" 
        stroke="currentColor" 
        stroke-width="2" 
        stroke-linecap="round" 
        stroke-linejoin="round"
      >
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
      </svg>
    </button>
  </>
)}

<style is:global>
  .toc-nav {
    overflow: hidden auto;
    max-height: calc(100vh - 200px);
    opacity: 1;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    scrollbar-color: color-mix(in oklch, var(--token-purple-base) 30%, transparent) transparent;
    scrollbar-width: thin;
    will-change: max-height, opacity, transform;

    &::-webkit-scrollbar {
      width: 4px;
    }

    &::-webkit-scrollbar-track {
      background: transparent;
    }

    &::-webkit-scrollbar-thumb {
      border-radius: 2px;
      background: color-mix(in oklch, var(--token-purple-base) 30%, transparent);
    }

    &::-webkit-scrollbar-thumb:hover {
      background: color-mix(in oklch, var(--token-purple-base) 50%, transparent);
    }
  }

  .toc-container {
    position: sticky;
    top: 100px;
    z-index: var(-z-TableOfContents-toc-container);
    overflow-x: hidden;
    width: 18rem;
    height: fit-content;
    max-height: calc(100vh - 120px);
    padding: 10px 20px;
    border: none;
    border-radius: 12px;
    background: transparent;
    transition: all 0.3s ease;
    box-shadow: none;
    backdrop-filter: none;

    &::before {
    position: absolute;
    top: 0;
    right: 0;
    left: 0;
    height: 2px;
    content: '';
    border-radius: 12px 12px 0 0;
    opacity: 0.6;
    }

    /* デスクトップTOC専用のスタイル */
    &:not(.mobile-toc) {
      position: sticky;
      top: 100px;
      z-index: var(-z-TableOfContents-toc-container);
      overflow-x: hidden;
      width: 18rem;
      height: fit-content;
      max-height: calc(100vh - 120px);
      padding: 10px 20px;
      border: none;
      border-radius: 12px;
      background: transparent;
      transition: all 0.3s ease;
      box-shadow: none;
      backdrop-filter: none;
    }

    /* TOC States */
    &.toc-hidden {
      display: none;
    }

    &.toc-collapsed {
      width: auto;
      min-width: 200px;

      .toc-nav {
        overflow: hidden;
        max-height: 0;
        opacity: 0;
        transform: translateY(-8px);
      }
    }

    /* Legacy collapsed class support */
    &.collapsed {
      width: auto;
      min-width: 200px;

      .toc-nav {
        overflow: hidden;
        max-height: 0;
        opacity: 0;
      }
    }

    /* Mobile responsiveness - Hide desktop TOC on mobile */
    @media (max-width: 1200px) {
      &:not(.mobile-toc) {
        display: none;
      }
    }
  }

  .toc-header {
    position: relative;
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    margin: 10px 0;

    &::after {
    position: absolute;
    bottom: -1px;
    left: 0;
    width: 0%;
    height: 2px;
    border-radius: 1px;
      background: var(--token-purple-base);
    transition: width 0.3s ease;
    content: '';
    }
  }

  .toc-title {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 0;
    color: var(--token-purple-base);
    font-size: 16px;
    font-weight: 600;
  }

  .toc-toggle {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    min-width: 32px;
    min-height: 32px;
    padding: 8px;
    border: none;
    border-radius: 4px;
    background: none;
    color: var(--token-white-base);
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform, background-color, color;

  /* Tooltip for toggle */
    &::after {
    position: absolute;
    bottom: -35px;
    left: 50%;
    z-index: var(--z-TableOfContents-toc-toggle-after);
    padding: 4px 8px;
    border-radius: 4px;
      background: color-mix(in oklch, var(--token-white-base) 10%, transparent);
      color: var(--token-white-base);
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transform: translateX(-50%);
    transition: opacity 0.2s ease;
    content: attr(aria-label);
  }

    &:hover {
      background: color-mix(in oklch, var(--token-purple-base) 10%, transparent);
      color: var(--token-purple-base);

      &::after {
    opacity: 1;
      }
  }

    /* Hide toggle button on desktop - only allow collapse on mobile */
    @media (min-width: 1201px) {
    display: none;
  }
  }

  /* TOC Footer - Mobile only */
  .toc-footer {
    display: none;
    margin-top: 12px;
    padding-top: 12px;
    border-top: none;
  }

  .mobile-toc.toc-collapsed .toc-header {
    display: none;
  }

  .mobile-toc.toc-collapsed .toc-nav {
    display: none;
  }

  /* Remove footer margin and padding when TOC is collapsed */
  .mobile-toc.toc-collapsed .toc-footer {
    margin-top: 0;
    padding-top: 0;
  }

  /* Toggle button states - Clear visibility rules */
  .toc-toggle .toc-hide-icon {
    display: block;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform, opacity;
  }

  .toc-toggle .toc-show-icon {
    display: none;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform, opacity;
  }

  .toc-toggle:hover .toc-hide-icon,
  .toc-toggle:hover .toc-show-icon {
    transform: scale(1.1);
  }

  /* Floating toggle button - hidden since we only collapse now */
  .toc-floating-toggle {
    display: none;
  }

  .toc-expand-icon {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform;
  }

  .toc-expand-toggle {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    width: 100%;
    padding: 12px 16px;
    border: none;
    border-radius: 8px;
    background: linear-gradient(
      135deg,
      oklch(25% 0 0deg / 0.1) 0%,
      oklch(20% 0 0deg / 0.05) 100%
    );
    color: oklch(90% 0 0deg);
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    backdrop-filter: blur(8px);
    box-shadow: 
      0 1px 3px oklch(0% 0 0deg / 0.1),
      inset 0 1px 0 oklch(100% 0 0deg / 0.1);

    &:active {
      transform: translateY(0);
      transition-duration: 0.1s;
    }

    &[aria-expanded="true"] .toc-expand-icon {
      transform: rotate(180deg);
    }
  }

  .toc-expand-text {
    font-weight: 500;
  }


  /* Rotation effects for collapsed state */
  .toc-container.toc-collapsed .toc-toggle,
  .toc-toggle[aria-expanded="false"] {
    transform: rotate(0deg);
  }

  .toc-collapsed .toc-toggle:hover,
  .toc-toggle[aria-expanded="false"]:hover {
    transform: rotate(0deg) scale(1.1);
  }

  .toc-list {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  .toc-item {
    margin: 0;
  }

  .toc-link {
    position: relative;
    display: block;
    overflow-x: hidden;
    padding: 8px 10px;
    border-left: 3px solid transparent;
    border-radius: 6px;
    color: var(--token-white-base);
    font-size: 14px;
    line-height: 1.4;
    text-decoration: none;
    white-space: nowrap;
    transform: translateX(0);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    text-overflow: ellipsis;

    &:hover {
      background: color-mix(in oklch, var(--token-purple-base) 10%, transparent);
      color: var(--token-purple-base);
    transform: translateX(4px);
    }
  }

  /* Active link highlighting */
  .toc-link.active {
    border-left: 3px solid var(--token-purple-base);
    background: color-mix(in oklch, var(--token-purple-base) 15%, transparent);
    color: var(--token-purple-base);
    font-weight: 600;
    animation: activeGlow 0.3s ease-in-out;
    box-shadow: 0 2px 8px color-mix(in oklch, var(--token-purple-base) 20%, transparent);

    &::before {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    width: 3px;
    border-radius: 0 2px 2px 0;
      background: linear-gradient(180deg, var(--token-purple-base), color-mix(in oklch, var(--token-purple-base) 80%, var(--token-white-base)));
    content: '';
  }

    &::after {
    position: absolute;
    top: 50%;
    right: 8px;
    width: 6px;
    height: 6px;
    border-radius: 50%;
      background: var(--token-purple-base);
    transform: translateY(-50%);
    animation: pulse 2s infinite;
    content: '';
  }

    &:hover {
      background: color-mix(in oklch, var(--token-purple-base) 20%, transparent);
    transform: translateX(2px);
    }
  }

  @keyframes activeGlow {
    0% {
      background: color-mix(in oklch, var(--token-purple-base) 5%, transparent);
      transform: translateX(0);
    }

    50% {
      background: color-mix(in oklch, var(--token-purple-base) 20%, transparent);
      transform: translateX(4px);
    }

    100% {
      background: color-mix(in oklch, var(--token-purple-base) 15%, transparent);
      transform: translateX(0);
    }
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
      transform: translateY(-50%) scale(1);
    }

    50% {
      opacity: 0.6;
      transform: translateY(-50%) scale(1.2);
    }
  }

  /* Indentation levels */
  .toc-level-1 .toc-link {
    padding-left: 12px;
    font-weight: 600;
  }

  .toc-level-2 .toc-link {
    padding-left: 24px;
    font-size: 13px;
  }

  .toc-level-3 .toc-link {
    padding-left: 36px;
    font-size: 12px;
    opacity: 0.9;
  }

  .toc-level-4 .toc-link,
  .toc-level-5 .toc-link,
  .toc-level-6 .toc-link {
    padding-left: 48px;
    font-size: 12px;
    opacity: 0.8;
  }


  /* Mobile TOC - show as collapsible at top on mobile */
  @media (max-width: 1200px) {
    .toc-container.mobile-toc {
      position: relative;
      top: 0;
      right: auto;
      left: 0;
      z-index: auto;
      display: block;
      overflow-x: hidden;
      width: 100%;
      max-width: 100%;
      max-height: none;
      padding: 8px 16px;
      border: 1px solid oklch(100% 0 0deg / 0.12);
      border-radius: 16px;
      background: linear-gradient(
        135deg,
        oklch(20% 0 0deg / 0.15) 0%,
        oklch(15% 0 0deg / 0.1) 100%
      );
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(24px) saturate(1.2);
      box-shadow:
        0 4px 20px oklch(0% 0 0deg / 0.08),
        0 1px 3px oklch(0% 0 0deg / 0.12),
        inset 0 1px 0 oklch(100% 0 0deg / 0.15);
      touch-action: manipulation;

      .toc-title {
        font-size: 21px;
      font-weight: 600;
    }

      .toc-header {
        width: 100%;
        max-width: calc(100% - 1rem);
        margin: 0.5rem auto; /* 上下8px統一 */
        box-sizing: border-box;
      }

      /* Show TOC footer only on mobile */
      .toc-footer {
        display: block;
      }

      .toc-nav {
        max-height: 300px;
        transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        will-change: max-height, opacity, transform;
      }

      .toc-toggle {
        color: var(--token-white-base);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        will-change: transform, background-color, color;
      }
    }
    
    .mobile-toc.toc-collapsed .toc-nav {
      overflow: hidden;
      max-height: 0;
      opacity: 0;
      transform: translateY(-12px) scale(0.98);
    }


    .mobile-toc .toc-link {
      padding: 10px 12px;
      font-size: 14px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    /* Mobile indentation levels - 特異性を下げたセレクター */
    .mobile-toc .toc-level-1 {
      padding-left: 12px;
      font-size: 14px;
      font-weight: 600;
    }

    .mobile-toc .toc-level-2 {
      padding-left: 24px; /* デスクトップと同じインデント */
      font-size: 13px;
    }

    .mobile-toc .toc-level-3 {
      padding-left: 36px; /* デスクトップと同じインデント */
      font-size: 12px;
      opacity: 0.9;
    }

    .mobile-toc .toc-level-4,
    .mobile-toc .toc-level-5,
    .mobile-toc .toc-level-6 {
      padding-left: 48px; /* デスクトップと同じインデント */
      font-size: 12px;
      opacity: 0.8;
    }

    .mobile-toc .toc-link.active {
      position: relative;
      border-left: 4px solid var(--token-purple-base);
      background: color-mix(in oklch, var(--token-purple-base) 20%, transparent);
      color: var(--token-purple-base);
      font-weight: 600;
      animation: mobileActiveGlow 0.3s ease-in-out;
    }

    .toc-mobile-active::before {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      width: 4px;
      border-radius: 0 2px 2px 0;
      background: linear-gradient(180deg, var(--token-purple-base), color-mix(in oklch, var(--token-purple-base) 80%, var(--token-white-base)));
      content: '';
    }

    .toc-mobile-active::after {
      position: absolute;
      top: 50%;
      right: 12px;
      color: var(--token-purple-base);
      font-size: 8px;
      transform: translateY(-50%);
      animation: pulse 3s infinite;
      content: '●';
    }

    @keyframes mobileActiveGlow {
      0% {
        background: color-mix(in oklch, var(--token-purple-base) 10%, transparent);
      }

      50% {
        background: color-mix(in oklch, var(--token-purple-base) 25%, transparent);
      }

      100% {
        background: color-mix(in oklch, var(--token-purple-base) 20%, transparent);
      }
    }
  }

  /* Improved mobile styling */
  @media (max-width: 768px) {
      aside.toc-container.mobile-toc {
        position: relative;
        top: 0;
        right: auto;
        left: 0;
        overflow-x: hidden;
        width: 100%;
        max-width: 100vw;
        padding: 1rem;
        border: 1px solid oklch(100% 0 0deg / 0.12);
        border-radius: 16px;
        background: linear-gradient(
          135deg,
          oklch(20% 0 0deg / 0.15) 0%,
          oklch(15% 0 0deg / 0.1) 100%
        );
        box-sizing: border-box;
        backdrop-filter: blur(24px) saturate(1.2);
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const tocContainer = document.querySelector('.toc-container') as HTMLElement;
    const tocToggle = tocContainer?.querySelector('.toc-toggle') as HTMLButtonElement;
    const floatingToggle = document.querySelector('.toc-floating-toggle') as HTMLButtonElement;
    const tocLinks = tocContainer?.querySelectorAll('.toc-link') as NodeListOf<HTMLAnchorElement>;

    if (!tocContainer || !tocToggle || !floatingToggle || !tocLinks) {
      console.warn('TableOfContents: Missing required elements');
      return;
    }

    let isCollapsed = false;

    /** ------------------------------
     * Collapse/Expand TOC
     * ------------------------------ */
    const updateToggleState = (toggle: HTMLButtonElement, collapsed: boolean) => {
      if (collapsed) {
        toggle.setAttribute('aria-label', 'Expand table of contents');
        toggle.setAttribute('aria-expanded', 'false');
        toggle.setAttribute('data-state', 'collapsed');
      } else {
        toggle.setAttribute('aria-label', 'Collapse table of contents');
        toggle.setAttribute('aria-expanded', 'true');
        toggle.setAttribute('data-state', 'expanded');
      }
    };

    // Initialize button states
    updateToggleState(tocToggle, false);

    const collapseToc = () => {
      isCollapsed = true;
      tocContainer.classList.add('toc-collapsed');
      updateToggleState(tocToggle, true);
    };

    const expandToc = () => {
      isCollapsed = false;
      tocContainer.classList.remove('toc-collapsed');
      updateToggleState(tocToggle, false);
    };

    const toggleToc = () => {
      if (isCollapsed) {
        expandToc();
      } else {
        collapseToc();
      }
    };

    // Toggle button in TOC - simple collapse/expand
    tocToggle.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      toggleToc();
    });

    // Keyboard support for toggle
    tocToggle.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleToc();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        collapseToc();
      }
    });

    // Show button (floating) - now expands TOC
    floatingToggle.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      expandToc();
    });

    // Keyboard support for floating toggle
    floatingToggle.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        expandToc();
      }
    });

    /** ------------------------------
     * Hitung offset navbar dinamis
     * ------------------------------ */
    let cachedOffset: number | null = null;
    let lastCacheTime = 0;
    const getNavbarOffset = (): number => {
      const now = Date.now();
      if (cachedOffset !== null && now - lastCacheTime < 1000) return cachedOffset;
      const navbar = document.querySelector('nav, .navbar, header, [data-navbar], .header, #header, .top-nav, .main-nav') as HTMLElement;
      if (navbar) {
        const rect = navbar.getBoundingClientRect();
        const style = window.getComputedStyle(navbar);
        const isFixed = style.position === 'fixed' || style.position === 'sticky';
        if (isFixed && rect.height > 0) {
          cachedOffset = rect.height + 30;
        } else {
          cachedOffset = rect.height + 20;
        }
      } else {
        cachedOffset = 140; // fallback
      }
      lastCacheTime = now;
      return cachedOffset;
    };

    /** ------------------------------
     * Smooth scroll TOC links
     * ------------------------------ */
    tocLinks.forEach(link => {
      link.addEventListener('click', e => {
        e.preventDefault();
        e.stopPropagation();
        const targetId = link.getAttribute('href')?.slice(1);
        if (!targetId) return;
        const targetElement = document.getElementById(targetId);
        if (!targetElement) return;
        
        // Immediately update highlighting to the clicked link
        setActiveLinkManual(link);
        
        const offset = getNavbarOffset();
        const elementPosition = targetElement.getBoundingClientRect().top + window.scrollY - offset;
        window.scrollTo({
          top: elementPosition,
          behavior: 'smooth'
        });
      });
    });

    /** ------------------------------
     * Auto-scroll TOC to follow current section with highlighting
     * ------------------------------ */
    let currentActiveLink: Element | null = null;
    const tocNav = tocContainer.querySelector('.toc-nav') as HTMLElement;
    
    const setActiveLink = (link: Element | null) => {
      // Remove active class from previous link (both desktop and mobile)
      if (currentActiveLink) {
        currentActiveLink.classList.remove('active');
        // Also remove from mobile TOC if exists
        const mobileActiveLink = document.querySelector('.toc-container.mobile-toc .toc-link.active');
        if (mobileActiveLink) {
          mobileActiveLink.classList.remove('active');
        }
      }
      
      // Add active class to new link
      if (link) {
        link.classList.add('active');
        currentActiveLink = link;
        
        // Also update mobile TOC if exists
        const activeId = link.getAttribute('data-heading-id');
        if (activeId) {
          const mobileToc = document.querySelector('.toc-container.mobile-toc');
          if (mobileToc) {
            const mobileLinkActive = mobileToc.querySelector(`[data-heading-id="${activeId}"]`);
            if (mobileLinkActive) {
              mobileLinkActive.classList.add('active');
            }
          }
        }
        
        // Auto-scroll TOC to keep current link visible
        if (tocNav && !isCollapsed) {
          const linkRect = link.getBoundingClientRect();
          const navRect = tocNav.getBoundingClientRect();
          if (linkRect.top < navRect.top || linkRect.bottom > navRect.bottom) {
            tocNav.scrollTo({
              top: (link as HTMLElement).offsetTop - tocNav.offsetTop - navRect.height / 2 + linkRect.height / 2,
              behavior: 'smooth'
            });
          }
        }
      }
    };
    
    // Add a flag to prevent intersection observer from interfering with manual clicks
    let isManualClick = false;
    let manualClickTimeout: ReturnType<typeof setTimeout> | null = null;
    
    // Enhanced setActiveLink function that tracks manual clicks
    const setActiveLinkManual = (link: Element | null) => {
      isManualClick = true;
      if (manualClickTimeout) clearTimeout(manualClickTimeout);
      manualClickTimeout = setTimeout(() => {
        isManualClick = false;
      }, 1500); // Give 1.5 seconds for scroll to complete
      setActiveLink(link);
    };
    
    const observer = new IntersectionObserver(entries => {
      // Skip if this is a manual click
      if (isManualClick) return;
      
      entries.forEach(entry => {
        if (!entry.isIntersecting) return;
        const id = entry.target.getAttribute('id');
        if (!id) return;
        const newActiveLink = tocContainer.querySelector(`[data-heading-id="${id}"]`);
        if (!newActiveLink || newActiveLink === currentActiveLink) return;
        
        // Update active link with highlighting
        setActiveLink(newActiveLink);
      });
    }, { rootMargin: '-100px 0px -40% 0px', threshold: [0.1] });
    document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]').forEach(h => observer.observe(h));

    /** ------------------------------
     * Initial TOC position with highlighting
     * ------------------------------ */
    const initTOCPosition = () => {
      if (!tocContainer) return;
      const scrollTop = window.scrollY + getNavbarOffset();
      let chosenElement: HTMLElement | null = null;
      const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
      for (const h of Array.from(headings)) {
        const element = h as HTMLElement;
        if (element.offsetTop <= scrollTop) {
          chosenElement = element;
        }
      }
      if (chosenElement) {
        const id = chosenElement.getAttribute('id');
        if (id) {
          const link = tocContainer.querySelector(`[data-heading-id="${id}"]`);
          if (link) {
            setActiveLink(link);
            // Scroll TOC to show current section
            if (tocNav && !isCollapsed) {
              tocNav.scrollTo({
                top: (link as HTMLElement).offsetTop - tocNav.offsetTop - tocNav.offsetHeight / 2,
                behavior: 'smooth'
              });
            }
          }
        }
      }
    };
    setTimeout(initTOCPosition, 200);

    /** ------------------------------
     * Mobile TOC
     * ------------------------------ */
    const createMobileTOC = () => {
      const existing = document.querySelector('.toc-container.mobile-toc');
      if (window.innerWidth <= 1200) {
        if (!existing) {
          // Try multiple possible IDs for the main content element
          const contentMain = document.getElementById('contentMain') || 
                             document.getElementById('main-content') || 
                             document.querySelector('main') ||
                             document.querySelector('article');
          if (contentMain && contentMain.parentNode) {
            const clone = tocContainer.cloneNode(true) as HTMLElement;
            clone.classList.add('mobile-toc');
            
            // Re-attach event listeners to mobile TOC
            const mobileToggle = clone.querySelector('.toc-toggle') as HTMLButtonElement;
            const mobileLinks = clone.querySelectorAll('.toc-link') as NodeListOf<HTMLAnchorElement>;
            const mobileExpandToggle = clone.querySelector('.toc-expand-toggle') as HTMLButtonElement;
            
            // Shared state for mobile TOC
              let mobileCollapsed = false;
            
            if (mobileToggle) {
              
              const updateMobileToggleState = (collapsed: boolean) => {
                if (collapsed) {
                  mobileToggle.setAttribute('aria-label', 'Expand table of contents');
                  mobileToggle.setAttribute('aria-expanded', 'false');
                } else {
                  mobileToggle.setAttribute('aria-label', 'Collapse table of contents');
                  mobileToggle.setAttribute('aria-expanded', 'true');
                }
              };
              
              mobileToggle.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                 
                mobileCollapsed = !mobileCollapsed;
                if (mobileCollapsed) {
                  clone.classList.add('toc-collapsed');
                } else {
                  clone.classList.remove('toc-collapsed');
                }
                updateMobileToggleState(mobileCollapsed);
                 
                 // Reset expand toggle state when TOC is collapsed/expanded by toggle
                 const mobileExpandToggle = clone.querySelector('.toc-expand-toggle') as HTMLButtonElement;
                 if (mobileExpandToggle) {
                   if (mobileCollapsed) {
                     // When collapsed by toggle, reset expand toggle to normal state
                     mobileExpandToggle.setAttribute('aria-label', 'Expand table of contents');
                     mobileExpandToggle.setAttribute('aria-expanded', 'false');
                   } else {
                     // When expanded by toggle, reset expand toggle to normal state
                     mobileExpandToggle.setAttribute('aria-label', 'Expand table of contents');
                     mobileExpandToggle.setAttribute('aria-expanded', 'false');
                   }
                 }
              });
              
              // Initialize mobile toggle state
              updateMobileToggleState(mobileCollapsed);
            }
            
            // Mobile expand toggle functionality
            if (mobileExpandToggle) {
              let isExpanded = false;
              const mobileTocNav = clone.querySelector('.toc-nav') as HTMLElement;
              
              const updateExpandToggleState = (expanded: boolean) => {
                isExpanded = expanded;
                if (expanded) {
                  mobileExpandToggle.setAttribute('aria-label', 'Collapse table of contents');
                  mobileExpandToggle.setAttribute('aria-expanded', 'true');
                  if (mobileTocNav) {
                    mobileTocNav.style.maxHeight = 'none';
                    mobileTocNav.style.overflow = 'visible';
                  }
                } else {
                  mobileExpandToggle.setAttribute('aria-label', 'Expand table of contents');
                  mobileExpandToggle.setAttribute('aria-expanded', 'false');
                  if (mobileTocNav) {
                    mobileTocNav.style.maxHeight = '300px';
                    mobileTocNav.style.overflow = 'hidden auto';
                  }
                }
              };
              
              mobileExpandToggle.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Check if TOC is collapsed by toggle button
                if (mobileCollapsed) {
                  // State 2: TOC is collapsed by toggle, expand it back
                  clone.classList.remove('toc-collapsed');
                  mobileCollapsed = false;
                  
                  // Update mobile toggle state
                  const mobileToggle = clone.querySelector('.toc-toggle') as HTMLButtonElement;
                  if (mobileToggle) {
                    mobileToggle.setAttribute('aria-label', 'Collapse table of contents');
                    mobileToggle.setAttribute('aria-expanded', 'true');
                  }
                } else {
                  // State 1: Normal state, toggle expand/collapse of nav content
                  updateExpandToggleState(!isExpanded);
                }
              });
              
              // Initialize expand toggle state
              updateExpandToggleState(isExpanded);
            }
            
            mobileLinks.forEach(link => {
              link.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();
                const targetId = link.getAttribute('href')?.slice(1);
                if (!targetId) return;
                const targetElement = document.getElementById(targetId);
                if (!targetElement) return;
                
                // Find corresponding desktop link and update highlighting
                const desktopLink = tocContainer.querySelector(`[data-heading-id="${targetId}"]`);
                if (desktopLink) {
                  setActiveLinkManual(desktopLink);
                }
                
                const offset = getNavbarOffset();
                const elementPosition = targetElement.getBoundingClientRect().top + window.scrollY - offset;
                window.scrollTo({
                  top: elementPosition,
                  behavior: 'smooth'
                });
              });
            });
            
            // Apply current active state to mobile TOC
            if (currentActiveLink) {
              const activeId = currentActiveLink.getAttribute('data-heading-id');
              if (activeId) {
                const mobileLinkActive = clone.querySelector(`[data-heading-id="${activeId}"]`);
                if (mobileLinkActive) {
                  mobileLinkActive.classList.add('active');
                }
              }
            }
            
            contentMain.parentNode.insertBefore(clone, contentMain);
          }
        }
      } else if (existing) {
        existing.remove();
      }
    };
    
    createMobileTOC();
    window.addEventListener('resize', () => {
      cachedOffset = null;
      createMobileTOC();
    });
  });
 </script>

