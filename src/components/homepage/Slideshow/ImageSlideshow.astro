---
// Import slide data from config file
import { slides, slideshowConfig } from './slides.config';
import { Image } from 'astro:assets';
---

<div 
  class="slideshow-container w-full max-w-4xl mx-auto px-4 sm:px-6 lg:px-8"
  data-long-press-threshold={slideshowConfig.longPress.threshold}
  data-long-press-move-threshold={slideshowConfig.longPress.moveThreshold}
  data-long-press-enabled={slideshowConfig.longPress.enabled}
  data-long-press-indicator-text={slideshowConfig.longPress.indicatorText}
  data-long-press-resume-delay={slideshowConfig.longPress.resumeDelay}
  data-interval-duration={slideshowConfig.autoAdvanceInterval}
>
  <!-- Navigation dots - positioned above the slideshow -->
  <div class="flex justify-center space-x-1.5 sm:space-x-2 mb-4 sm:mb-6">
    {slides.map((_, index) => (
      <div class="relative">
        <button 
          class={`dot w-3 h-3 sm:w-4 sm:h-4 rounded-full transition-all duration-300 shadow-lg ${index === 0 ? 'active-dot' : ''}`}
          data-dot-index={index}
        ></button>
        {index === 0 && (
          <span class="absolute right-0 bottom-1 left-1/2 transform -translate-x-1/2 text-xs sm:text-xl">ðŸ“Œ</span>
        )}
      </div>
    ))}
  </div>

  <!-- Slideshow wrapper with 3:2 aspect ratio -->
  <div class="relative w-full bg-card rounded-lg overflow-hidden shadow-lg" style="aspect-ratio: 3/2;">
    <!-- Loading placeholder -->
    <div class="absolute inset-0 bg-muted animate-pulse flex items-center justify-center">
      <div class="text-muted-foreground">Loading...</div>
    </div>
    
    <!-- Slides -->
    {slides.map((slide, index) => (
      <div 
        class={`slide absolute inset-0 transition-opacity duration-500 cursor-pointer ${index === 0 ? 'opacity-100' : 'opacity-0'}`}
        data-slide-index={index}
        data-link={slide.link}
      >
        <Image 
          loading={index === 0 ? "eager" : "lazy"}
          fetchpriority={index === 0 ? "high" : "low"}
          src={slide.imageUrl} 
          alt={slide.alt}
          class="w-full h-full object-cover"
          width={800}
          height={533}
          format="webp"
          quality={85}
        />
        <!-- Gradient overlay for better text visibility -->
        <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent pointer-events-none"></div>
      </div>
    ))}
    
    <!-- ENHANCED Progress bar - Always visible with better styling -->
    <div class="absolute bottom-0 left-0 w-full h-1.5 bg-black/30 backdrop-blur-sm">
      <div 
        class="progress-bar h-full transition-all duration-100 ease-linear" 
        style="width: 0%; background: linear-gradient(90deg, var(--color-accent-purple) 0%, var(--color-accent-purple-dark) 100%);"
      ></div>
    </div>
    
    <!-- Long-press indicator (hidden by default) -->
    <div class="long-press-indicator absolute inset-0 bg-black/10 opacity-0 transition-opacity duration-200 pointer-events-none flex items-center justify-center">
      <div class="bg-white/90 rounded-lg px-4 py-2 text-sm font-medium text-gray-800 shadow-lg">
        {slideshowConfig.longPress.indicatorText}
      </div>
    </div>
  </div>
</div>

<script>
  // Type definitions for better TypeScript support
  interface Slide {
    id: number;
    imageUrl: string;
    link: string;
    alt: string;
    title?: string;
  }

  class ImageSlideshow {
    private container!: HTMLElement | null;
    private slides!: NodeListOf<Element>;
    private dots!: NodeListOf<Element>;
    private progressBar!: HTMLElement | null;
    private longPressIndicator!: HTMLElement | null;
    private currentIndex!: number;
    private intervalDuration!: number;
    private interval!: number | null;
    private progressInterval!: number | null;
    
    // Touch and long-press properties
    private touchStartTime!: number;
    private longPressTimer!: number | null;
    private isLongPressing!: boolean;
    private longPressThreshold!: number;
    private touchStartPosition!: { x: number; y: number };
    private touchMoveThreshold!: number;
    private hasMoved!: boolean;
    
    // Progress tracking for pause/resume
    private pausedProgress!: number;
    private resumeDelay!: number;
    private progressStartTime!: number;
    
    constructor() {
      this.container = document.querySelector('.slideshow-container');
      if (!this.container) return;
      
      this.slides = this.container.querySelectorAll('.slide');
      this.dots = this.container.querySelectorAll('.dot');
      this.progressBar = this.container.querySelector('.progress-bar');
      this.longPressIndicator = this.container.querySelector('.long-press-indicator');
      this.currentIndex = 0;
      this.intervalDuration = parseInt(this.container.dataset.intervalDuration || '5000');
      this.interval = null;
      this.progressInterval = null;
      
      // Touch and long-press initialization
      this.touchStartTime = 0;
      this.longPressTimer = null;
      this.isLongPressing = false;
      this.longPressThreshold = parseInt(this.container.dataset.longPressThreshold || '750');
      this.touchStartPosition = { x: 0, y: 0 };
      this.touchMoveThreshold = parseInt(this.container.dataset.longPressMoveThreshold || '10');
      this.hasMoved = false;
      
      // Progress tracking initialization
      this.pausedProgress = 0;
      this.resumeDelay = parseInt(this.container.dataset.longPressResumeDelay || '500');
      this.progressStartTime = 0;

      this.init();
    }
    
    init(): void {
      // Add click listeners to slides
      this.slides.forEach((slide: Element) => {
        slide.addEventListener('click', this.handleSlideClick.bind(this));
      });
      
      // Add click listeners to dots
      this.dots.forEach((dot: Element, index: number) => {
        dot.addEventListener('click', () => this.goToSlide(index));
      });
      
      // Add touch event listeners for mobile long-press (only if enabled)
      const longPressEnabled = this.container?.dataset.longPressEnabled === 'true';
      if (longPressEnabled) {
        this.addTouchEventListeners();
      }
      
      // Start autoplay
      this.startAutoplay();
      
      // Pause on hover (desktop only)
      this.container?.addEventListener('mouseenter', this.pauseAutoplay.bind(this));
      this.container?.addEventListener('mouseleave', this.startAutoplay.bind(this));
    }
    
    addTouchEventListeners(): void {
      if (!this.container) return;
      
      // Touch start
      this.container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
      
      // Touch move
      this.container.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
      
      // Touch end
      this.container.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
      
      // Touch cancel
      this.container.addEventListener('touchcancel', this.handleTouchCancel.bind(this), { passive: false });
    }
    
    handleTouchStart(event: TouchEvent): void {
      const touch = event.touches[0];
      if (!touch) return;
      
      this.touchStartTime = Date.now();
      this.touchStartPosition = { x: touch.clientX, y: touch.clientY };
      this.isLongPressing = false;
      this.hasMoved = false;
      
      // Clear any existing timer
      if (this.longPressTimer) {
        clearTimeout(this.longPressTimer);
        this.longPressTimer = null;
      }
      
      // Start long-press timer
      this.longPressTimer = window.setTimeout(() => {
        if (!this.hasMoved && !this.isLongPressing) {
          this.handleLongPress();
        }
      }, this.longPressThreshold);
    }
    
    handleTouchMove(event: TouchEvent): void {
      const touch = event.touches[0];
      if (!touch || !this.touchStartPosition) return;
      
      const moveDistance = Math.sqrt(
        Math.pow(touch.clientX - this.touchStartPosition.x, 2) +
        Math.pow(touch.clientY - this.touchStartPosition.y, 2)
      );
      
      // Mark as moved if distance exceeds threshold
      if (moveDistance > this.touchMoveThreshold) {
        this.hasMoved = true;
        this.cancelLongPress();
      }
    }
    
    handleTouchEnd(event: TouchEvent): void {
      const touchEndTime = Date.now();
      const touchDuration = touchEndTime - this.touchStartTime;
      
      // Always call endLongPress if we were long-pressing
      if (this.isLongPressing) {
        this.endLongPress();
        return;
      }
      
      // Handle other touch scenarios
      if (touchDuration < this.longPressThreshold && !this.hasMoved) {
        this.cancelLongPress();
        if (!this.interval) {
          this.startAutoplay();
        }
      } else {
        this.cancelLongPress();
        if (!this.interval) {
          this.startAutoplay();
        }
        event.preventDefault();
        event.stopPropagation();
      }
    }
    
    handleTouchCancel(): void {
      this.cancelLongPress();
    }
    
    handleLongPress(): void {
      this.isLongPressing = true;
      this.pauseAutoplay();
      this.showLongPressIndicator();
    }
    
    endLongPress(): void {
      this.isLongPressing = false;
      this.hideLongPressIndicator();
      
      // Immediately reset touch state
      this.resetTouchState();
      
      // Add delay before resuming
      setTimeout(() => {
        this.startAutoplay();
        this.pausedProgress = 0;
      }, this.resumeDelay);
    }
    
    cancelLongPress(): void {
      if (this.longPressTimer) {
        clearTimeout(this.longPressTimer);
        this.longPressTimer = null;
      }
      this.isLongPressing = false;
      this.hideLongPressIndicator();
    }
    
    resetTouchState(): void {
      this.isLongPressing = false;
      this.hasMoved = false;
      this.touchStartTime = 0;
      if (this.longPressTimer) {
        clearTimeout(this.longPressTimer);
        this.longPressTimer = null;
      }
    }
    
    showLongPressIndicator(): void {
      if (this.longPressIndicator) {
        this.longPressIndicator.classList.remove('opacity-0');
        this.longPressIndicator.classList.add('opacity-100');
      }
    }
    
    hideLongPressIndicator(): void {
      if (this.longPressIndicator) {
        this.longPressIndicator.classList.remove('opacity-100');
        this.longPressIndicator.classList.add('opacity-0');
      }
    }
    
    handleSlideClick(event: Event): void {
      // Don't handle click if we were long-pressing
      if (this.isLongPressing) {
        event.preventDefault();
        event.stopPropagation();
        return;
      }
      
      const target = event.currentTarget as HTMLElement;
      const link = target.dataset.link;
      if (!link) return;
      
      // Open all links in new tab for consistent behavior
      window.open(link, '_blank', 'noopener,noreferrer');
    }
    
    goToSlide(index: number): void {
      // Force resume slideshow if it was paused by long-press
      if (this.isLongPressing) {
        this.isLongPressing = false;
        this.hideLongPressIndicator();
        this.resetTouchState();
      }
      
      // Hide current slide
      this.slides[this.currentIndex].classList.remove('opacity-100');
      this.slides[this.currentIndex].classList.add('opacity-0');
      this.dots[this.currentIndex].classList.remove('active-dot');
      
      // Remove emoji from current active dot
      const currentDotContainer = this.dots[this.currentIndex].parentElement;
      const currentEmoji = currentDotContainer?.querySelector('span');
      if (currentEmoji) {
        currentEmoji.remove();
      }
      
      // Show new slide
      this.currentIndex = index;
      this.slides[this.currentIndex].classList.remove('opacity-0');
      this.slides[this.currentIndex].classList.add('opacity-100');
      this.dots[this.currentIndex].classList.add('active-dot');
      
      // Add emoji to new active dot
      const newDotContainer = this.dots[this.currentIndex].parentElement;
      if (newDotContainer) {
        const emoji = document.createElement('span');
        emoji.className = 'absolute right-0 bottom-1 left-1/2 transform -translate-x-1/2 text-xs sm:text-xl';
        emoji.textContent = 'ðŸ“Œ';
        newDotContainer.appendChild(emoji);
      }
      
      // Reset progress and ensure autoplay is running
      this.resetProgress();
      if (!this.interval) {
        this.startAutoplay();
      }
    }
    
    nextSlide(): void {
      const nextIndex = (this.currentIndex + 1) % this.slides.length;
      this.goToSlide(nextIndex);
    }
    
    startAutoplay(): void {
      this.pauseAutoplay();
      
      // Start progress animation immediately
      this.startProgress();
      
      // Start slide interval
      this.interval = window.setInterval(() => {
        this.nextSlide();
      }, this.intervalDuration);
    }
    
    pauseAutoplay(): void {
      // Store current progress before pausing
      if (this.progressBar) {
        const currentWidth = this.progressBar.style.width;
        this.pausedProgress = parseFloat(currentWidth) || 0;
      }
      
      if (this.interval) {
        clearInterval(this.interval);
        this.interval = null;
      }
      if (this.progressInterval) {
        clearInterval(this.progressInterval);
        this.progressInterval = null;
      }
    }
    
    startProgress(): void {
      if (!this.progressBar) return;
      
      // ENHANCED: Always start fresh progress animation
      this.progressStartTime = Date.now();
      let progress = this.pausedProgress;
      const increment = 100 / (this.intervalDuration / 50); // Update every 50ms
      
      // Set initial progress
      this.progressBar.style.width = progress + '%';
      
      // Clear any existing progress interval
      if (this.progressInterval) {
        clearInterval(this.progressInterval);
      }
      
      this.progressInterval = window.setInterval(() => {
        progress += increment;
        if (progress >= 100) {
          progress = 100;
          if (this.progressInterval) {
            clearInterval(this.progressInterval);
            this.progressInterval = null;
          }
        }
        if (this.progressBar) {
          this.progressBar.style.width = progress + '%';
        }
      }, 50);
    }
    
    resetProgress(): void {
      if (this.progressBar) {
        this.progressBar.style.width = '0%';
        this.pausedProgress = 0;
      }
      if (this.progressInterval) {
        clearInterval(this.progressInterval);
        this.progressInterval = null;
      }
    }
  }
  
  // Initialize slideshow when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    new ImageSlideshow();
  });
</script>