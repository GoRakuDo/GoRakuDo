---
// ========== BEM METHOD - TOOL INDEX PAGE ==========
// Architect Optimization: BEM-compliant, performance-first approach
// Purpose: Display all articles for a specific tool category with optimal performance
// File: src/pages/tools/[tool]/index.astro

// Import required dependencies
import { getCollection, type CollectionEntry } from 'astro:content';
import { getVisibleToolArticles } from '../../../utils/content/PostStatus-Filter';
import ArticleLayout from '../../../layouts/ArticleLayout.astro';
import ToolIdContentGrid from '../../../components/tools/Tool-IdContentGrid.astro';
import Breadcrumb from '../../../components/common/Breadcrumb.astro';
import SearchPopover from '../../../components/common/SearchPopover.astro';
// ToolIdHeader component has been integrated directly into this file

// Breadcrumb Schema
import { generateBreadcrumbSchema } from '../../../utils/breadcrumb-schema';

// Import BEM-compliant tool styles
import '../../../styles/pages/tools/[tool]/Tool-IdIndex.css';

// ========== BEM METHOD - TOOL DISCOVERY ==========
// Optimized tool discovery with caching and error handling
async function getValidToolsFromCollection() {
  try {
    const allArticles = await getCollection('tool-articles');
    const articles = getVisibleToolArticles(allArticles);
    const toolNames = new Set<string>();

    articles.forEach((article: CollectionEntry<'tool-articles'>) => {
      if (article.data.toolName) {
        toolNames.add(article.data.toolName.toLowerCase());
      }
    });

    return Array.from(toolNames).sort();
  } catch (error) {
    console.error('Failed to load tools from collection:', error);
    return [];
  }
}

// ========== BEM METHOD - STATIC PATH GENERATION ==========
export async function getStaticPaths() {
  const getAllToolsFromCollection = async () => {
    try {
      const allArticles = await getCollection('tool-articles');
      const toolNames = new Set<string>();

      // すべての記事（公開・非公開問わず）からツール名を取得
      allArticles.forEach((article: CollectionEntry<'tool-articles'>) => {
        if (article.data.toolName) {
          toolNames.add(article.data.toolName.toLowerCase());
        }
      });

      return Array.from(toolNames).sort();
    } catch (error) {
      console.error('Failed to load tools from collection:', error);
      return [];
    }
  };

  const allTools = await getAllToolsFromCollection();
  return allTools.length === 0
    ? []
    : allTools.map(tool => ({
        params: { tool },
        props: { toolName: tool },
      }));
}

// ========== BEM METHOD - COMPONENT LOGIC ==========
const { tool } = Astro.params as { tool: string };

// Early validation and redirect
if (!tool) return Astro.redirect('/tools', 301);

// Get all tools and validate
const getAllToolsFromCollection = async () => {
  try {
    const allArticles = await getCollection('tool-articles');
    const toolNames = new Set<string>();

    allArticles.forEach((article: CollectionEntry<'tool-articles'>) => {
      if (article.data.toolName) {
        toolNames.add(article.data.toolName.toLowerCase());
      }
    });

    return Array.from(toolNames).sort();
  } catch (error) {
    console.error('Failed to load tools from collection:', error);
    return [];
  }
};

const allTools = await getAllToolsFromCollection();
if (allTools.length === 0 || !allTools.includes(tool.toLowerCase())) {
  return Astro.redirect('/tools', 301);
}

// Fetch and filter articles
const allArticles = await getCollection('tool-articles');
const articles = getVisibleToolArticles(allArticles);

// Filter articles for this tool (direct toolName match)
const directToolArticles = articles.filter(
  (article: CollectionEntry<'tool-articles'>) =>
    article.data.toolName?.toLowerCase() === tool.toLowerCase()
);

// Filter articles that mention this tool in relatedTools
const relatedToolArticles = articles.filter(
  (article: CollectionEntry<'tool-articles'>) =>
    article.data.relatedTools?.some(
      (relatedTool: string) => relatedTool.toLowerCase() === tool.toLowerCase()
    )
);

// Combine and deduplicate articles
const allToolArticles = [...directToolArticles, ...relatedToolArticles];
const uniqueToolArticles = allToolArticles.filter(
  (
    article: CollectionEntry<'tool-articles'>,
    index: number,
    self: CollectionEntry<'tool-articles'>[]
  ) =>
    index ===
    self.findIndex(
      (a: CollectionEntry<'tool-articles'>) => a.slug === article.slug
    )
);

const toolArticles = uniqueToolArticles;

// Check if there are any visible articles for this tool
const hasVisibleArticles = toolArticles.length > 0;

// ========== BEM METHOD - CENTRALIZED DATA MANAGEMENT ==========
// All data processing centralized here for maximum efficiency and maintainability

// Tool configuration mapping
const toolConfigs = {
  anki: {
    iconPath: '/icon/anki-icon-240.webp',
    description:
      'Anki adalah aplikasi flashcard yang sangat powerful untuk menghafal kosakata bahasa Jepang. Dengan sistem spaced repetition, Anki membantu Anda mengingat kata-kata dengan lebih efektif dan efisien.',
  },
  migaku: {
    iconPath: '/icon/migaku-icon-240.webp',
    description:
      'Migaku adalah platform pembelajaran bahasa Jepang yang komprehensif dengan fokus pada immersion learning. Pelajari bahasa Jepang melalui konten asli seperti anime, manga, dan drama dengan bantuan AI.',
  },
  yomitan: {
    iconPath: '/icon/yomitan-icon-240.webp',
    description:
      'Yomitan adalah browser extension yang memudahkan membaca teks bahasa Jepang. Dengan hover dictionary dan furigana generation, Yomitan membuat proses pembelajaran menjadi lebih interaktif dan menyenangkan.',
  },
} as const;

// Centralized data processing
const toolConfig = toolConfigs[
  tool.toLowerCase() as keyof typeof toolConfigs
] || {
  iconPath: '/icon/yomitan-icon-240.webp',
  description: `Comprehensive learning resources and guides for mastering ${tool}. From beginner basics to advanced techniques, everything you need to succeed.`,
};

const formattedToolName = tool.charAt(0).toUpperCase() + tool.slice(1);
const currentYear = new Date(
  (toolArticles[0] as CollectionEntry<'tool-articles'>)?.data.publishedDate ||
    new Date()
).getFullYear();

// ========== BEM METHOD - PROCESSED ARTICLE DATA ==========
// Pre-process all article data for components
const processedArticles = toolArticles.map(
  (article: CollectionEntry<'tool-articles'>, index: number) => {
    // Article slug processing
    const articleSlug =
      article.slug?.split('/').slice(1).join('/') || article.id;

    // Determine article type (direct tool article or related tool article)
    const isDirectToolArticle =
      article.data.toolName?.toLowerCase() === tool.toLowerCase();
    const isRelatedToolArticle = article.data.relatedTools?.some(
      (relatedTool: string) => relatedTool.toLowerCase() === tool.toLowerCase()
    );

    // Article title processing
    const articleTitle =
      article.data.title || `Complete ${formattedToolName} Guide`;

    // Article description processing
    const articleDescription =
      article.data.description ||
      `Master ${tool} with our comprehensive guide. Learn essential techniques, best practices, and advanced tips.`;

    // Article tags processing
    const DEFAULT_TAGS = ['guide', 'tutorial'];
    const articleTags = article.data.tags?.length
      ? article.data.tags
      : [tool, ...DEFAULT_TAGS];
    const displayTags = articleTags.slice(0, 3); // Max 3 tags for display

    // Article date processing
    const DATE_LOCALE = 'id-ID';
    const publishedDate = article.data.publishedDate
      ? new Date(article.data.publishedDate).toLocaleDateString(DATE_LOCALE)
      : new Date().toLocaleDateString(DATE_LOCALE);

    // Article image processing
    const articleImage =
      article.data.featuredImage || article.data.image || null;
    const hasImage = Boolean(articleImage?.trim());

    return {
      slug: articleSlug,
      title: articleTitle,
      description: articleDescription,
      tags: displayTags,
      publishedDate,
      image: articleImage,
      hasImage,
      originalArticle: article,
      index,
      // Add article type information
      isDirectToolArticle,
      isRelatedToolArticle,
      articleType: isDirectToolArticle ? 'direct' : 'related',
    };
  }
);

// ========== BEM METHOD - HEADER DATA ==========
// Pre-processed header data
const headerData = {
  tool,
  articleCount: toolArticles.length,
  title: `Apa itu ${formattedToolName} ?`,
  description: toolConfig.description,
  iconPath: toolConfig.iconPath,
  formattedToolName,
  currentYear,
};

// ========== INTEGRATED TOOL-IdHeader LOGIC ==========
// Optimized constants for display
const ICON_DIMENSIONS = { width: 175, height: 175 };
const iconAlt = `${headerData.formattedToolName} tool icon`;

// Optimized meta items with better performance and accessibility
const META_ITEMS = [
  {
    icon: 'M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z',
    label:
      headerData.articleCount === 0
        ? 'No Articles'
        : headerData.articleCount === 1
          ? '1 Article'
          : `${headerData.articleCount} Articles`,
    ariaLabel: `This tool has ${headerData.articleCount} articles available`,
  },
  {
    icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z',
    label: 'Free Resources',
    ariaLabel: 'All resources are free to use',
  },
] as const;

// ========== BEM METHOD - CONTENT GRID DATA ==========
// Pre-processed content grid data
const contentGridData = {
  hasArticles: toolArticles.length > 0,
  toolArticles: processedArticles,
  tool,
  formattedToolName,
};

// ========== BEM METHOD - BREADCRUMB SCHEMA ==========
// Tool page用のBreadcrumb Schema生成
const breadcrumbSchema = generateBreadcrumbSchema({
  items: [
    { title: 'Home', url: '/', isActive: false },
    { title: 'Tools', url: '/tools', isActive: false },
    { title: formattedToolName, url: `/tools/${tool}`, isActive: true },
  ],
  siteUrl: String(Astro.site || 'https://gorakudo.org'),
});
---

<ArticleLayout
  title={`${formattedToolName} - GoRakuDo`}
  description={`All articles and guides for ${tool} tool`}
  lang='id'
  breadcrumbSchema={breadcrumbSchema}
>
  <!-- ========== INTEGRATED ENHANCED HEADER COMPONENT ========== -->
  <header
    slot='articles-header'
    class='component-header'
    role='banner'
    itemscope
    itemtype='https://schema.org/WebPageElement'
  >
    <div class='header-container glassmorphism glassmorphism-card'>
      <!-- Integrated Content Section with Icon and Text -->
      <div class='header-content-section'>
        <!-- Icon Container -->
        <div class='tool-icon-container'>
          <img
            src={headerData.iconPath}
            alt={iconAlt}
            class='tool-icon-large'
            loading='eager'
            width={ICON_DIMENSIONS.width}
            height={ICON_DIMENSIONS.height}
            itemprop='image'
          />
        </div>

        <!-- Text Content -->
        <div class='header-text-content'>
          <h1 class='header-title' itemprop='headline'>
            {headerData.title}
          </h1>
          <p class='header-description' itemprop='description'>
            {headerData.description}
          </p>
          <div class='header-meta' role='list' aria-label='Tool statistics'>
            {
              META_ITEMS.map(item => (
                <span
                  class='meta-item'
                  role='listitem'
                  aria-label={item.ariaLabel}
                >
                  <svg
                    class='meta-icon'
                    fill='none'
                    stroke='currentColor'
                    viewBox='0 0 24 24'
                    aria-hidden='true'
                  >
                    <path
                      stroke-linecap='round'
                      stroke-linejoin='round'
                      stroke-width='2'
                      d={item.icon}
                    />
                  </svg>
                  {item.label}
                </span>
              ))
            }
          </div>
        </div>
      </div>
    </div>
  </header>

  <Breadcrumb
    slot='breadcrumb'
    currentPath={`/tools/${tool}`}
    showHome={true}
    orientation='horizontal'
    showIcons={true}
    ariaLabel='Tool navigation breadcrumb'
  />

  <SearchPopover
    slot='search'
    buttonStyle='rounded'
    placeholder={`Search ${formattedToolName} articles...`}
    searchAction={`/search?tool=${tool}`}
    className='tool-search-popover'
    toolFilter={tool}
    searchCollections='tools'
  />

  <ToolIdContentGrid
    hasArticles={contentGridData.hasArticles}
    toolArticles={contentGridData.toolArticles}
    tool={contentGridData.tool}
    formattedToolName={contentGridData.formattedToolName}
  />
</ArticleLayout>
