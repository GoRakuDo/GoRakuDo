---
// ========== BEM METHOD - TOOL INDEX PAGE ==========
// Architect Optimization: BEM-compliant, performance-first approach
// Purpose: Display all articles for a specific tool category with optimal performance
// File: src/pages/tools/[tool]/index.astro

// Import required dependencies
import { getCollection, type CollectionEntry } from 'astro:content';
import { getVisibleToolArticles } from '../../../utils/content/PostStatus-Filter';
import ArticleLayout from '../../../layouts/ArticleLayout.astro';
import ToolIdContentGrid from '../../../components/tools/Tool-IdContentGrid.astro';
import Breadcrumb from '../../../components/common/Breadcrumb.astro';
import SearchPopover from '../../../components/common/SearchPopover.astro';
import toolsData from '../../../data/tools.json';
import toolSeoTemplate from './_tool-seo.json';
// ToolIdHeader component has been integrated directly into this file

// Breadcrumb Schema
import { generateBreadcrumbSchema } from '../../../utils/breadcrumb-schema';

// Import BEM-compliant tool styles
import '../../../styles/pages/tools/[tool]/Tool-IdIndex.css';

// ========== BEM METHOD - TOOL DISCOVERY ==========
// Optimized tool discovery with caching and error handling
async function getValidToolsFromCollection() {
  try {
    const allArticles = await getCollection('tool-articles');
    const articles = getVisibleToolArticles(allArticles);
    const toolNames = new Set<string>();

    articles.forEach((article: CollectionEntry<'tool-articles'>) => {
      if (article.data.toolName) {
        toolNames.add(article.data.toolName.toLowerCase());
      }
    });

    return Array.from(toolNames).sort();
  } catch (error) {
    console.error('Failed to load tools from collection:', error);
    return [];
  }
}

// ========== BEM METHOD - STATIC PATH GENERATION ==========
export async function getStaticPaths() {
  const getAllToolsFromCollection = async () => {
    try {
      const allArticles = await getCollection('tool-articles');
      const toolNames = new Set<string>();

      // すべての記事（公開・非公開問わず）からツール名を取得
      allArticles.forEach((article: CollectionEntry<'tool-articles'>) => {
        if (article.data.toolName) {
          toolNames.add(article.data.toolName.toLowerCase());
        }
      });

      return Array.from(toolNames).sort();
    } catch (error) {
      console.error('Failed to load tools from collection:', error);
      return [];
    }
  };

  const allTools = await getAllToolsFromCollection();
  return allTools.length === 0
    ? []
    : allTools.map(tool => ({
        params: { tool },
        props: { toolName: tool },
      }));
}

// ========== BEM METHOD - COMPONENT LOGIC ==========
const { tool } = Astro.params as { tool: string };

// Early validation and redirect
if (!tool) return Astro.redirect('/tools', 301);

// Get all tools and validate
const getAllToolsFromCollection = async () => {
  try {
    const allArticles = await getCollection('tool-articles');
    const toolNames = new Set<string>();

    allArticles.forEach((article: CollectionEntry<'tool-articles'>) => {
      if (article.data.toolName) {
        toolNames.add(article.data.toolName.toLowerCase());
      }
    });

    return Array.from(toolNames).sort();
  } catch (error) {
    console.error('Failed to load tools from collection:', error);
    return [];
  }
};

const allTools = await getAllToolsFromCollection();
if (allTools.length === 0 || !allTools.includes(tool.toLowerCase())) {
  return Astro.redirect('/tools', 301);
}

// Fetch and filter articles
const allArticles = await getCollection('tool-articles');
const articles = getVisibleToolArticles(allArticles);

// Filter articles for this tool (direct toolName match)
const directToolArticles = articles.filter(
  (article: CollectionEntry<'tool-articles'>) =>
    article.data.toolName?.toLowerCase() === tool.toLowerCase()
);

// Filter articles that mention this tool in relatedTools
const relatedToolArticles = articles.filter(
  (article: CollectionEntry<'tool-articles'>) =>
    article.data.relatedTools?.some(
      (relatedTool: string) => relatedTool.toLowerCase() === tool.toLowerCase()
    )
);

// Combine and deduplicate articles
const allToolArticles = [...directToolArticles, ...relatedToolArticles];
const uniqueToolArticles = allToolArticles.filter(
  (
    article: CollectionEntry<'tool-articles'>,
    index: number,
    self: CollectionEntry<'tool-articles'>[]
  ) =>
    index ===
    self.findIndex(
      (a: CollectionEntry<'tool-articles'>) => a.slug === article.slug
    )
);

const toolArticles = uniqueToolArticles;

// Check if there are any visible articles for this tool
const hasVisibleArticles = toolArticles.length > 0;

// ========== BEM METHOD - CENTRALIZED DATA MANAGEMENT ==========
// All data processing centralized here for maximum efficiency and maintainability

// Tool configuration - simplified
const toolConfig = {
  iconPath: '/icon/yomitan-icon-240.webp',
  description: `Comprehensive learning resources and guides for mastering ${tool}. From beginner basics to advanced techniques, everything you need to succeed.`,
};

const formattedToolName = tool.charAt(0).toUpperCase() + tool.slice(1);
const currentYear = new Date(
  (toolArticles[0] as CollectionEntry<'tool-articles'>)?.data.publishedDate ||
    new Date()
).getFullYear();

// ========== BEM METHOD - PROCESSED ARTICLE DATA ==========
// Pre-process all article data for components
const processedArticles = toolArticles.map(
  (article: CollectionEntry<'tool-articles'>, index: number) => {
    // Article slug processing
    const articleSlug =
      article.slug?.split('/').slice(1).join('/') || article.id;

    // Determine article type (direct tool article or related tool article)
    const isDirectToolArticle =
      article.data.toolName?.toLowerCase() === tool.toLowerCase();
    const isRelatedToolArticle = article.data.relatedTools?.some(
      (relatedTool: string) => relatedTool.toLowerCase() === tool.toLowerCase()
    );

    // Article title processing
    const articleTitle =
      article.data.title || `Complete ${formattedToolName} Guide`;

    // Article description processing
    const articleDescription =
      article.data.description ||
      `Master ${tool} with our comprehensive guide. Learn essential techniques, best practices, and advanced tips.`;

    // Article tags processing
    const DEFAULT_TAGS = ['guide', 'tutorial'];
    const articleTags = article.data.tags?.length
      ? article.data.tags
      : [tool, ...DEFAULT_TAGS];
    const displayTags = articleTags.slice(0, 3); // Max 3 tags for display

    // Article date processing
    const DATE_LOCALE = 'id-ID';
    const publishedDate = article.data.publishedDate
      ? new Date(article.data.publishedDate).toLocaleDateString(DATE_LOCALE)
      : new Date().toLocaleDateString(DATE_LOCALE);

    // Article image processing
    const articleImage =
      article.data.featuredImage || article.data.image || null;
    const hasImage = Boolean(articleImage?.trim());

    return {
      slug: articleSlug,
      title: articleTitle,
      description: articleDescription,
      tags: displayTags,
      publishedDate,
      image: articleImage,
      hasImage,
      originalArticle: article,
      index,
      // Add article type information
      isDirectToolArticle,
      isRelatedToolArticle,
      articleType: isDirectToolArticle ? 'direct' : 'related',
    };
  }
);

// ========== BEM METHOD - HEADER DATA ==========
// Pre-processed header data
const headerData = {
  tool,
  articleCount: toolArticles.length,
  title: `Apa itu ${formattedToolName} ?`,
  description: toolConfig.description,
  iconPath: toolConfig.iconPath,
  formattedToolName,
  currentYear,
};

// ========== INTEGRATED TOOL-IdHeader LOGIC ==========
// Optimized constants for display
const ICON_DIMENSIONS = { width: 175, height: 175 };
const iconAlt = `${headerData.formattedToolName} tool icon`;

// Optimized meta items with better performance and accessibility
const META_ITEMS = [
  {
    icon: 'M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z',
    label:
      headerData.articleCount === 0
        ? 'No Articles'
        : headerData.articleCount === 1
          ? '1 Article'
          : `${headerData.articleCount} Articles`,
    ariaLabel: `This tool has ${headerData.articleCount} articles available`,
  },
  {
    icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z',
    label: 'Free Resources',
    ariaLabel: 'All resources are free to use',
  },
] as const;

// ========== BEM METHOD - CONTENT GRID DATA ==========
// Pre-processed content grid data
const contentGridData = {
  hasArticles: toolArticles.length > 0,
  toolArticles: processedArticles,
  tool,
  formattedToolName,
};

// ========== DYNAMIC SEO DATA GENERATION ==========
// JSONテンプレートから動的にSEOデータを生成
const replaceTemplateVariables = (
  template: string,
  variables: Record<string, string>
): string => {
  return template.replace(
    /\{\{(\w+)\}\}/g,
    (match, key) => variables[key] || match
  );
};

const replaceTemplateArray = (
  template: string[],
  variables: Record<string, string>
): string[] => {
  return template.map(item => replaceTemplateVariables(item, variables));
};

const replaceTemplateObject = (
  template: any,
  variables: Record<string, string>
): any => {
  if (typeof template === 'string') {
    return replaceTemplateVariables(template, variables);
  } else if (Array.isArray(template)) {
    return template.map(item => replaceTemplateObject(item, variables));
  } else if (template && typeof template === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(template)) {
      result[key] = replaceTemplateObject(value, variables);
    }
    return result;
  }
  return template;
};

// テンプレート変数の定義
const templateVariables = {
  tool: tool,
  toolName: formattedToolName,
  formattedToolName: formattedToolName,
  toolDescription: toolConfig.description,
  articleCount: toolArticles.length.toString(),
};

// SEOデータをテンプレートから生成
const seoData = replaceTemplateObject(
  toolSeoTemplate.seoData,
  templateVariables
);

// ========== STRUCTURED DATA GENERATION ==========
// 構造化データをテンプレートから生成
const softwareApplicationSchema = replaceTemplateObject(
  toolSeoTemplate.structuredData.softwareApplication,
  templateVariables
);

// CollectionPage構造化データをテンプレートから生成
const collectionPageTemplate = replaceTemplateObject(
  toolSeoTemplate.structuredData.collectionPage,
  templateVariables
);
const collectionPageSchema = {
  ...collectionPageTemplate,
  mainEntity: {
    ...collectionPageTemplate.mainEntity,
    itemListElement: toolArticles.map(
      (article: CollectionEntry<'tool-articles'>, index: number) => ({
        '@type': 'ListItem',
        position: index + 1,
        item: {
          '@type': 'Article',
          name: article.data.title || `Panduan ${formattedToolName}`,
          description:
            article.data.description || `Panduan lengkap ${formattedToolName}`,
          url: `/tools/${tool}/${article.slug}`,
          datePublished: article.data.publishedDate,
          author: {
            '@type': 'Organization',
            name: 'GoRakuDo Team',
          },
        },
      })
    ),
  },
};

// FAQ構造化データをテンプレートから生成
const faqSchema = replaceTemplateObject(
  toolSeoTemplate.structuredData.faq,
  templateVariables
);

// ========== BEM METHOD - BREADCRUMB SCHEMA ==========
// パンくずリストをテンプレートから生成
const breadcrumbData = replaceTemplateObject(
  toolSeoTemplate.breadcrumbData,
  templateVariables
);
const breadcrumbSchema = generateBreadcrumbSchema({
  items: breadcrumbData.items.map((item, index) => ({
    title: item.name || item.title,
    url: item.url,
    isActive: index === breadcrumbData.items.length - 1,
  })),
  siteUrl: String(Astro.site || 'https://gorakudo.org'),
});
---

<ArticleLayout
  title={seoData.title}
  description={seoData.description}
  lang='id'
  author={seoData.author}
  breadcrumbSchema={breadcrumbSchema}
>
  <!-- 2025 SEO Optimization: Technical SEO -->
  <link rel='canonical' href={`${Astro.site}/tools/${tool}`} />
  <meta
    name='robots'
    content='index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1'
  />
  <meta
    name='googlebot'
    content='index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1'
  />
  <meta
    name='bingbot'
    content='index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1'
  />

  <!-- Performance Optimization -->
  <link rel='preconnect' href='https://fonts.googleapis.com' />
  <link rel='preconnect' href='https://fonts.gstatic.com' crossorigin />
  <link rel='dns-prefetch' href='//cdn.jsdelivr.net' />
  <link rel='dns-prefetch' href='//github.com' />

  <!-- Critical Resource Preloading -->
  <link
    rel='preload'
    href='/styles/pages/tools/[tool]/Tool-IdIndex.css'
    as='style'
  />

  <!-- Security Headers -->
  <meta http-equiv='X-Content-Type-Options' content='nosniff' />
  <meta http-equiv='X-XSS-Protection' content='1; mode=block' />

  <!-- Structured Data: SoftwareApplication -->
  <script
    type='application/ld+json'
    set:html={JSON.stringify(softwareApplicationSchema)}
  />

  <!-- Structured Data: CollectionPage -->
  <script
    type='application/ld+json'
    set:html={JSON.stringify(collectionPageSchema)}
  />

  <!-- Structured Data: FAQ -->
  <script type='application/ld+json' set:html={JSON.stringify(faqSchema)} />

  <!-- ========== INTEGRATED ENHANCED HEADER COMPONENT ========== -->
  <header
    slot='articles-header'
    class='component-header'
    role='banner'
    itemscope
    itemtype='https://schema.org/WebPageElement'
  >
    <div class='header-container glassmorphism glassmorphism-card'>
      <!-- Integrated Content Section with Icon and Text -->
      <div class='header-content-section'>
        <!-- Icon Container -->
        <div class='tool-icon-container'>
          <img
            src={headerData.iconPath}
            alt={iconAlt}
            class='tool-icon-large'
            loading='eager'
            width={ICON_DIMENSIONS.width}
            height={ICON_DIMENSIONS.height}
            itemprop='image'
          />
        </div>

        <!-- Text Content -->
        <div class='header-text-content'>
          <h1 class='header-title' itemprop='headline'>
            {headerData.title}
          </h1>
          <p class='header-description' itemprop='description'>
            {headerData.description}
          </p>
          <div class='header-meta' role='list' aria-label='Tool statistics'>
            {
              META_ITEMS.map(item => (
                <span
                  class='meta-item'
                  role='listitem'
                  aria-label={item.ariaLabel}
                >
                  <svg
                    class='meta-icon'
                    fill='none'
                    stroke='currentColor'
                    viewBox='0 0 24 24'
                    aria-hidden='true'
                  >
                    <path
                      stroke-linecap='round'
                      stroke-linejoin='round'
                      stroke-width='2'
                      d={item.icon}
                    />
                  </svg>
                  {item.label}
                </span>
              ))
            }
          </div>
        </div>
      </div>
    </div>
  </header>

  <Breadcrumb
    slot='breadcrumb'
    currentPath={`/tools/${tool}`}
    showHome={true}
    orientation='horizontal'
    showIcons={true}
    ariaLabel='Tool navigation breadcrumb'
  />

  <SearchPopover
    slot='search'
    buttonStyle='rounded'
    placeholder={`Search ${formattedToolName} articles...`}
    searchAction={`/search?tool=${tool}`}
    className='tool-search-popover'
    toolFilter={tool}
    searchCollections='tools'
  />

  <ToolIdContentGrid
    hasArticles={contentGridData.hasArticles}
    toolArticles={contentGridData.toolArticles}
    tool={contentGridData.tool}
    formattedToolName={contentGridData.formattedToolName}
  />
</ArticleLayout>

<script>
  // ========== 2025 SEO OPTIMIZATION: PERFORMANCE MONITORING ==========
  // Core Web Vitals monitoring (simplified for 2025)
  function monitorCoreWebVitals() {
    // Basic performance monitoring without external dependencies
    if ('performance' in window && 'PerformanceObserver' in window) {
      try {
        const observer = new PerformanceObserver(list => {
          list.getEntries().forEach(entry => {
            if (entry.entryType === 'largest-contentful-paint') {
              console.log('LCP:', entry.startTime);
            } else if (entry.entryType === 'first-input') {
              const fidEntry = entry as any;
              console.log('FID:', fidEntry.processingStart - entry.startTime);
            } else if (entry.entryType === 'layout-shift') {
              const clsEntry = entry as any;
              console.log('CLS:', clsEntry.value);
            }
          });
        });

        observer.observe({
          entryTypes: [
            'largest-contentful-paint',
            'first-input',
            'layout-shift',
          ],
        });
      } catch (error) {
        console.log('Performance monitoring not available:', error);
      }
    }
  }

  // Intersection Observer for lazy loading optimization
  function optimizeLazyLoading() {
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver(
        (entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target as HTMLImageElement;
              if (img.dataset.src) {
                img.src = img.dataset.src;
                img.removeAttribute('data-src');
                observer.unobserve(img);
              }
            }
          });
        },
        {
          rootMargin: '50px 0px',
          threshold: 0.01,
        }
      );

      document.querySelectorAll('img[data-src]').forEach(img => {
        imageObserver.observe(img);
      });
    }
  }

  // Service Worker registration for caching
  function registerServiceWorker() {
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker
          .register('/sw.js', {
            scope: '/',
            updateViaCache: 'none',
          })
          .then(registration => {
            console.log('SW registered: ', registration);

            // Check for updates
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              if (newWorker) {
                newWorker.addEventListener('statechange', () => {
                  if (
                    newWorker.state === 'installed' &&
                    navigator.serviceWorker.controller
                  ) {
                    // New content available, notify user
                    if (confirm('New version available! Reload to update?')) {
                      window.location.reload();
                    }
                  }
                });
              }
            });
          })
          .catch(registrationError => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }
  }

  // Initialize all optimizations
  document.addEventListener('DOMContentLoaded', () => {
    monitorCoreWebVitals();
    optimizeLazyLoading();
    registerServiceWorker();
  });
</script>
