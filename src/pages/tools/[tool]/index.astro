---
// ========== IMPORTS ==========
import { getCollection, type CollectionEntry } from 'astro:content';
import { getVisibleToolArticles } from '../../../utils/content/PostStatus-Filter';
import ArticleLayout from '../../../layouts/ArticleLayout.astro';
import ToolIdContentGrid from '../../../components/tools/Tool-IdContentGrid.astro';
import Breadcrumb from '../../../components/common/Breadcrumb.astro';
import SearchPopover from '../../../components/common/SearchPopover.astro';
import Pagination from '../../../components/common/Pagination/Pagination.astro';
import {
  calculatePagination,
  type PaginationConfig,
} from '../../../components/common/Pagination/pagination';
import { generateBreadcrumbSchema } from '../../../utils/breadcrumb-schema';
import toolsData from '../../../data/tools.json';
import toolSeoTemplate from '../../../data/seo/pages/tool-template.json';
import '../../../styles/pages/tools/[tool]/Tool-IdIndex.css';

// ========== CONSTANTS ==========
const ARTICLES_PER_PAGE = 6;

// ========== STATIC PATH GENERATION ==========
export async function getStaticPaths() {
  const getAllToolsFromCollection = async () => {
    try {
      const allArticles = await getCollection('tool-articles');
      const toolNames = new Set<string>();
      allArticles.forEach((article: CollectionEntry<'tool-articles'>) => {
        if (article.data.toolName) {
          toolNames.add(article.data.toolName.toLowerCase());
        }
      });
      return Array.from(toolNames).sort();
    } catch (error) {
      console.error('Failed to load tools from collection:', error);
      return [];
    }
  };

  const allTools = await getAllToolsFromCollection();
  return allTools.length === 0
    ? []
    : allTools.map(tool => ({ params: { tool }, props: { toolName: tool } }));
}

// ========== COMPONENT LOGIC ==========
const { tool } = Astro.params as { tool: string };

if (!tool) return Astro.redirect('/tools', 301);

const getAllToolsFromCollection = async () => {
  try {
    const allArticles = await getCollection('tool-articles');
    const toolNames = new Set<string>();
    allArticles.forEach((article: CollectionEntry<'tool-articles'>) => {
      if (article.data.toolName) {
        toolNames.add(article.data.toolName.toLowerCase());
      }
    });
    return Array.from(toolNames).sort();
  } catch (error) {
    console.error('Failed to load tools from collection:', error);
    return [];
  }
};

const allTools = await getAllToolsFromCollection();
if (allTools.length === 0 || !allTools.includes(tool.toLowerCase())) {
  return Astro.redirect('/tools', 301);
}

// ========== DATA PROCESSING ==========
const allArticles = await getCollection('tool-articles');
const articles = getVisibleToolArticles(allArticles);

const directToolArticles = articles.filter(
  (article: CollectionEntry<'tool-articles'>) =>
    article.data.toolName?.toLowerCase() === tool.toLowerCase()
);

const relatedToolArticles = articles.filter(
  (article: CollectionEntry<'tool-articles'>) =>
    article.data.relatedTools?.some(
      (relatedTool: string) => relatedTool.toLowerCase() === tool.toLowerCase()
    )
);

const allToolArticles = [...directToolArticles, ...relatedToolArticles];
const toolArticles = allToolArticles
  .filter(
    (
      article: CollectionEntry<'tool-articles'>,
      index: number,
      self: CollectionEntry<'tool-articles'>[]
    ) =>
      index ===
      self.findIndex(
        (a: CollectionEntry<'tool-articles'>) => a.slug === article.slug
      )
  )
  .sort(
    (
      a: CollectionEntry<'tool-articles'>,
      b: CollectionEntry<'tool-articles'>
    ) => {
      const dateA = new Date(a.data.publishedDate || a.data.createdDate || 0);
      const dateB = new Date(b.data.publishedDate || b.data.createdDate || 0);
      return dateB.getTime() - dateA.getTime();
    }
  );

// ========== PAGINATION LOGIC ==========
const totalPages = Math.ceil(toolArticles.length / ARTICLES_PER_PAGE);
const paginationConfig: PaginationConfig = {
  postsPerPage: ARTICLES_PER_PAGE,
  currentPage: 1,
  totalPosts: toolArticles.length,
};

const paginationResult = calculatePagination(toolArticles, paginationConfig);
const { paginatedItems: paginatedToolArticles } = paginationResult;

// ========== TOOL CONFIGURATION ==========
const toolData = toolsData.find(t => t.id === tool);
const toolConfig = {
  iconPath: toolData?.iconUrl || '/icon/yomitan-icon-240.webp',
  description:
    toolData?.description ||
    `Tutorial Aplikasi ${tool}. Dari dasar pemula hingga teknik lanjutan, semua yang kalian butuhkan untuk belajar bahasa Jepang.`,
};

const formattedToolName =
  toolData?.name || tool.charAt(0).toUpperCase() + tool.slice(1);
const currentYear = new Date(
  (toolArticles[0] as CollectionEntry<'tool-articles'>)?.data.publishedDate ||
    new Date()
).getFullYear();

// ========== PROCESSED ARTICLE DATA ==========
const processedArticles = paginatedToolArticles.map(
  (article: CollectionEntry<'tool-articles'>, index: number) => {
    const articleSlug =
      article.slug?.split('/').slice(1).join('/') || article.id;
    const isDirectToolArticle =
      article.data.toolName?.toLowerCase() === tool.toLowerCase();
    const isRelatedToolArticle = article.data.relatedTools?.some(
      (relatedTool: string) => relatedTool.toLowerCase() === tool.toLowerCase()
    );
    const articleTitle =
      article.data.title || `Tutorial Aplikasi ${formattedToolName}`;
    const articleDescription =
      article.data.description ||
      `Artikel Tutorial dari Aplikasi ${tool}. Dari dasar pemula hingga teknik lanjutan, semua yang kalian butuhkan untuk belajar bahasa Jepang.`;
    const DEFAULT_TAGS = ['guide', 'tutorial'];
    const articleTags = article.data.tags?.length
      ? article.data.tags
      : [tool, ...DEFAULT_TAGS];
    const displayTags = articleTags.slice(0, 3);
    const DATE_LOCALE = 'id-ID';
    const publishedDate = article.data.publishedDate
      ? new Date(article.data.publishedDate).toLocaleDateString(DATE_LOCALE)
      : new Date().toLocaleDateString(DATE_LOCALE);
    const articleImage =
      article.data.featuredImage || article.data.image || null;
    const hasImage = Boolean(articleImage?.trim());

    return {
      slug: articleSlug,
      title: articleTitle,
      description: articleDescription,
      tags: displayTags,
      publishedDate,
      image: articleImage,
      hasImage,
      devicePlatform: article.data.devicePlatform || 'Windows',
      originalArticle: article,
      index,
      isDirectToolArticle,
      isRelatedToolArticle,
      articleType: isDirectToolArticle ? 'direct' : 'related',
    };
  }
);

// ========== HEADER DATA ==========
const headerData = {
  tool,
  articleCount: toolArticles.length,
  title: `Apa itu ${formattedToolName} ?`,
  description: toolConfig.description,
  iconPath: toolConfig.iconPath,
  formattedToolName,
  currentYear,
};

// ========== DISPLAY CONSTANTS ==========
const ICON_DIMENSIONS = { width: 175, height: 175 };
const iconAlt = `${headerData.formattedToolName} tool icon`;

const META_ITEMS = [
  {
    icon: 'M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z',
    label:
      headerData.articleCount === 0
        ? 'No Articles'
        : headerData.articleCount === 1
          ? '1 Article'
          : `${headerData.articleCount} Articles`,
    ariaLabel: `This tool has ${headerData.articleCount} articles available`,
  },
  {
    icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z',
    label: 'Free Resources',
    ariaLabel: 'All resources are free to use',
  },
] as const;

// ========== CONTENT GRID DATA ==========
const contentGridData = {
  hasArticles: toolArticles.length > 0,
  toolArticles: processedArticles,
  tool,
  formattedToolName,
};

// ========== SEO DATA GENERATION ==========
const replaceTemplateVariables = (
  template: string,
  variables: Record<string, string>
): string => {
  return template.replace(
    /\{\{(\w+)\}\}/g,
    (match, key) => variables[key] || match
  );
};

const replaceTemplateObject = (
  template: any,
  variables: Record<string, string>
): any => {
  if (typeof template === 'string') {
    return replaceTemplateVariables(template, variables);
  } else if (Array.isArray(template)) {
    return template.map(item => replaceTemplateObject(item, variables));
  } else if (template && typeof template === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(template)) {
      result[key] = replaceTemplateObject(value, variables);
    }
    return result;
  }
  return template;
};

const templateVariables = {
  tool,
  toolName: formattedToolName,
  formattedToolName,
  toolDescription: toolConfig.description,
  articleCount: toolArticles.length.toString(),
};

const seoData = replaceTemplateObject(
  toolSeoTemplate.seoData,
  templateVariables
);

// seoDataが生成された後にテンプレート変数を更新
const templateVariablesWithSeo = {
  ...templateVariables,
  seoTitle: seoData.title,
  seoDescription: seoData.description,
};

// ========== STRUCTURED DATA GENERATION ==========
const softwareApplicationSchema = {
  ...replaceTemplateObject(
    toolSeoTemplate.structuredData.softwareApplication,
    templateVariablesWithSeo
  ),
  url: String(Astro.site || 'https://gorakudo.org') + Astro.url.pathname,
};

const collectionPageTemplate = replaceTemplateObject(
  toolSeoTemplate.structuredData.collectionPage,
  templateVariablesWithSeo
);

const collectionPageSchema = {
  ...collectionPageTemplate,
  url: String(Astro.site || 'https://gorakudo.org') + Astro.url.pathname,
  mainEntity: {
    ...collectionPageTemplate.mainEntity,
    itemListElement: toolArticles.map(
      (article: CollectionEntry<'tool-articles'>, index: number) => ({
        '@type': 'ListItem',
        position: index + 1,
        item: {
          '@type': 'Article',
          name: article.data.title || `Panduan ${formattedToolName}`,
          description:
            article.data.description || `Panduan lengkap ${formattedToolName}`,
          url: `/tools/${tool}/${article.slug}`,
          datePublished: article.data.publishedDate,
          author: { '@type': 'Organization', name: 'GoRakuDo Team' },
        },
      })
    ),
  },
};

// FAQ Schema is now handled by UnifiedSEO via toolSeoTemplate.structuredData.faq

const breadcrumbData = replaceTemplateObject(
  toolSeoTemplate.breadcrumbData,
  templateVariablesWithSeo
);
const breadcrumbSchema = generateBreadcrumbSchema({
  items: breadcrumbData.items.map((item, index) => ({
    title: item.name || item.title,
    url: item.url,
    isActive: index === breadcrumbData.items.length - 1,
  })),
  siteUrl: String(Astro.site || 'https://gorakudo.org'),
});
---

<ArticleLayout
  title={seoData.title}
  description={seoData.description}
  lang='id'
  author={seoData.author}
  currentPage={1}
  totalPages={totalPages}
  baseUrl={`/tools/${tool}`}
  breadcrumbSchema={breadcrumbSchema}
  faqSchema={replaceTemplateObject(
    toolSeoTemplate.structuredData.faq,
    templateVariablesWithSeo
  )}
  collectionPageSchema={collectionPageSchema}
  softwareApplicationSchema={softwareApplicationSchema}
>
  <!-- ========== INTEGRATED ENHANCED HEADER COMPONENT ========== -->
  <header
    slot='articles-header'
    class='component-header'
    role='banner'
    itemscope
    itemtype='https://schema.org/WebPageElement'
  >
    <div class='header-container glassmorphism glassmorphism-card'>
      <!-- Integrated Content Section with Icon and Text -->
      <div class='header-content-section'>
        <!-- Icon Container -->
        <div class='tool-icon-container'>
          <img
            src={headerData.iconPath}
            alt={iconAlt}
            class='tool-icon-large'
            loading='eager'
            width={ICON_DIMENSIONS.width}
            height={ICON_DIMENSIONS.height}
            itemprop='image'
          />
        </div>

        <!-- Text Content -->
        <div class='header-text-content'>
          <h1 class='header-title' itemprop='headline'>
            {headerData.title}
          </h1>
          <p class='header-description' itemprop='description'>
            {headerData.description}
          </p>
          <div class='header-meta' role='list' aria-label='Tool statistics'>
            {
              META_ITEMS.map(item => (
                <span
                  class='meta-item'
                  role='listitem'
                  aria-label={item.ariaLabel}
                >
                  <svg
                    class='meta-icon'
                    fill='none'
                    stroke='currentColor'
                    viewBox='0 0 24 24'
                    aria-hidden='true'
                  >
                    <path
                      stroke-linecap='round'
                      stroke-linejoin='round'
                      stroke-width='2'
                      d={item.icon}
                    />
                  </svg>
                  {item.label}
                </span>
              ))
            }
          </div>
        </div>
      </div>
    </div>
  </header>

  <Breadcrumb
    slot='breadcrumb'
    currentPath={`/tools/${tool}`}
    showHome={true}
    orientation='horizontal'
    showIcons={true}
    ariaLabel='Tool navigation breadcrumb'
  />

  <SearchPopover
    slot='search'
    buttonStyle='rounded'
    placeholder={`Search ${formattedToolName} articles...`}
    searchAction={`/search?tool=${tool}`}
    className='tool-search-popover'
    toolFilter={tool}
    searchCollections='tools'
  />

  <ToolIdContentGrid
    hasArticles={contentGridData.hasArticles}
    toolArticles={contentGridData.toolArticles}
    tool={contentGridData.tool}
    formattedToolName={contentGridData.formattedToolName}
  />

  {
    totalPages > 1 && (
      <Pagination
        slot='pagination'
        currentPage={1}
        totalPages={totalPages}
        baseUrl={`/tools/${tool}`}
        showPageInfo={true}
      />
    )
  }
</ArticleLayout>

<!-- ========== SCRIPTS ========== -->
<script>
  // Lazy loading
  const initLazyLoading = () => {
    if (!('IntersectionObserver' in window)) return;

    const observer = new IntersectionObserver(
      (entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
              observer.unobserve(img);
            }
          }
        });
      },
      { rootMargin: '50px 0px', threshold: 0.01 }
    );

    document
      .querySelectorAll('img[data-src]')
      .forEach(img => observer.observe(img));
  };

  // Initialize all
  const init = () => {
    initLazyLoading();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
