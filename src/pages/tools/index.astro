---
// ========== IMPORTS ==========
import BaseLayout from '../../layouts/BaseLayout.astro';
import ToolsGridSection from '../../components/tools/Tools-GridSection.astro';
import { generateBreadcrumbSchema } from '../../utils/breadcrumb-schema';
import toolsData from '../../data/tools.json';
import toolsSeoData from '../../data/seo/tools.json';
import '../../styles/pages/tools/tools-index.css';

// ========== TYPE DEFINITIONS ==========
interface Tool {
  readonly id: string;
  readonly name: string;
  readonly description: string;
  readonly iconUrl: string;
  readonly color?: string;
  readonly link: string;
}

// ========== DATA & CONFIGURATION ==========
const tools: Tool[] = toolsData as Tool[];

const STATS_CONFIG = {
  tools: { label: 'Tools Terpilih', suffix: '+' },
  free: { label: 'Gratis', value: '100%' },
  access: { label: 'Akses', value: '24/7' },
} as const;

const TITLE_CONFIG = {
  main: 'Tools & Aplikasi',
  accent: 'Pembelajaran Bahasa Jepang',
} as const;

const DESCRIPTION =
  'Pilih tool yang sesuai dengan tahap pembelajaran dan kebutuhan Anda. Setiap tool telah dipilih berdasarkan efektivitas dan kemudahan penggunaan.';

// ========== UTILITY FUNCTIONS ==========
const getStatsData = (toolsCount: number) => [
  {
    number: `${toolsCount}${STATS_CONFIG.tools.suffix}`,
    label: STATS_CONFIG.tools.label,
  },
  { number: STATS_CONFIG.free.value, label: STATS_CONFIG.free.label },
  { number: STATS_CONFIG.access.value, label: STATS_CONFIG.access.label },
];

// ========== PROCESSED DATA ==========
const toolsCount = tools.length;
const statsData = getStatsData(toolsCount);
const seoData = toolsSeoData.seoData;

// ========== STRUCTURED DATA ==========
const breadcrumbSchema = generateBreadcrumbSchema({
  items: toolsSeoData.breadcrumbData.items.map(item => ({
    title: item.title,
    url: item.url,
    isActive: item.isActive,
  })),
  siteUrl: String(Astro.site || 'https://gorakudo.org'),
});

const faqSchema = {
  '@context': 'https://schema.org' as const,
  '@type': 'FAQPage' as const,
  mainEntity: toolsSeoData.structuredData.faq.mainEntity.map(faq => ({
    '@type': 'Question' as const,
    name: faq.name,
    acceptedAnswer: {
      '@type': 'Answer' as const,
      text: faq.acceptedAnswer.text,
    },
  })),
};
---

<BaseLayout
  title={seoData.title}
  description={seoData.description}
  keywords={seoData.keywords}
  pageType={seoData.pageType as 'article' | 'website'}
  lang='id'
  breadcrumbSchema={breadcrumbSchema}
  faqSchema={faqSchema}
>
  <!-- Structured Data: CollectionPage -->
  <script
    type='application/ld+json'
    set:html={JSON.stringify(toolsSeoData.structuredData.collectionPage)}
  />
  <!-- Main Content -->
  <main
    class='main-content min-h-screen tools-layout-optimized'
    role='main'
    transition:name='main-content'
    aria-label='Japanese learning tools and applications'
  >
    <!-- Tools Header Section -->
    <section
      class='tools-header-section'
      aria-labelledby='tools-header-title'
      role='banner'
      transition:name='tools-header'
      itemscope
      itemtype='https://schema.org/WebPageElement'
    >
      <div class='tools-header-container'>
        <!-- Main Content -->
        <div class='tools-header-content'>
          <header class='tools-header-main'>
            <h2
              class='tools-header-title'
              id='tools-header-title'
              itemprop='headline'
            >
              <span class='tools-title-main'>{TITLE_CONFIG.main}</span>
              <span class='tools-title-accent'>{TITLE_CONFIG.accent}</span>
            </h2>

            <p class='tools-header-description' itemprop='description'>
              {DESCRIPTION}
            </p>
          </header>

          <!-- Stats Section -->
          <div
            class='tools-header-stats'
            role='region'
            aria-label='Tools statistics'
          >
            {
              statsData.map((stat, index) => (
                <>
                  <div
                    class='tools-stat-item'
                    itemprop='mainEntity'
                    itemscope
                    itemtype='https://schema.org/QuantitativeValue'
                  >
                    <span class='tools-stat-number' itemprop='value'>
                      {stat.number}
                    </span>
                    <span class='tools-stat-label' itemprop='name'>
                      {stat.label}
                    </span>
                  </div>
                  {index < statsData.length - 1 && (
                    <div class='tools-stat-divider' aria-hidden='true' />
                  )}
                </>
              ))
            }
          </div>
        </div>
      </div>
    </section>

    <!-- Tools Grid Section - 統合されたコンポーネント -->
    <ToolsGridSection tools={tools} />
  </main>
</BaseLayout>

<!-- ========== SCRIPTS ========== -->
<script>
  // Page animations
  const initPageAnimations = () => {
    const mainContent = document.querySelector('.main-content');
    if (mainContent) mainContent.classList.add('page-load-fade-in');

    const toolCards = document.querySelectorAll('.tool-card');
    toolCards.forEach((card, index) => {
      (card as HTMLElement).style.setProperty(
        '--stagger-delay',
        `${index * 0.1}s`
      );
      card.classList.add('stagger-animation');
    });
  };

  // Micro-interactions
  const initMicroInteractions = () => {
    const elements = document.querySelectorAll(`
        .tool-card,
        .tools-section a,
        .tools-section button,
        .main-content a:not([href="/"]),
        .main-content button:not(.get-started-btn):not(.mobile-menu-btn)
      `);
    elements.forEach(element =>
      element.classList.add('micro-interaction-scale')
    );
  };

  // Tool card interactions
  const initToolCardInteractions = () => {
    const toolCards = document.querySelectorAll('.tool-card');
    toolCards.forEach(card => {
      card.addEventListener('click', e => {
        e.preventDefault();
        card.classList.add('is-interacting');
        setTimeout(() => {
          card.classList.remove('is-interacting');
          window.location.href = (card as HTMLAnchorElement).href;
        }, 150);
      });
    });
  };

  // Stats animation
  const initStatsAnimation = () => {
    const statsItems = document.querySelectorAll(
      '.tools-stat-item'
    ) as NodeListOf<HTMLElement>;
    if (!('IntersectionObserver' in window)) return;

    const observer = new IntersectionObserver(
      entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const element = entry.target as HTMLElement;
            element.style.opacity = '1';
            element.style.transform = 'translateY(0)';
            observer.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.1, rootMargin: '0px 0px -50px 0px' }
    );

    statsItems.forEach(item => {
      item.style.opacity = '0';
      item.style.transform = 'translateY(20px)';
      item.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
      observer.observe(item);
    });
  };

  // Performance monitoring
  const initPerformanceMonitoring = () => {
    if (!('performance' in window && 'PerformanceObserver' in window)) return;

    try {
      const observer = new PerformanceObserver(list => {
        list.getEntries().forEach(entry => {
          if (entry.entryType === 'largest-contentful-paint') {
            console.log('LCP:', entry.startTime);
          } else if (entry.entryType === 'first-input') {
            const fidEntry = entry as any;
            console.log('FID:', fidEntry.processingStart - entry.startTime);
          } else if (entry.entryType === 'layout-shift') {
            const clsEntry = entry as any;
            console.log('CLS:', clsEntry.value);
          }
        });
      });

      observer.observe({
        entryTypes: ['largest-contentful-paint', 'first-input', 'layout-shift'],
      });
    } catch (error) {
      console.log('Performance monitoring not available:', error);
    }
  };

  // Lazy loading
  const initLazyLoading = () => {
    if (!('IntersectionObserver' in window)) return;

    const observer = new IntersectionObserver(
      (entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
              observer.unobserve(img);
            }
          }
        });
      },
      { rootMargin: '50px 0px', threshold: 0.01 }
    );

    document
      .querySelectorAll('img[data-src]')
      .forEach(img => observer.observe(img));
  };

  // Service Worker
  const initServiceWorker = () => {
    if (!('serviceWorker' in navigator)) return;

    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register('/sw.js', { scope: '/', updateViaCache: 'none' })
        .then(registration => {
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (!newWorker) return;

            newWorker.addEventListener('statechange', () => {
              if (
                newWorker.state === 'installed' &&
                navigator.serviceWorker.controller
              ) {
                if (confirm('New version available! Reload to update?')) {
                  window.location.reload();
                }
              }
            });
          });
        })
        .catch(error => console.log('SW registration failed:', error));
    });
  };

  // Initialize all
  const init = () => {
    initPageAnimations();
    initMicroInteractions();
    initToolCardInteractions();
    initStatsAnimation();
    initPerformanceMonitoring();
    initLazyLoading();
    initServiceWorker();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
