---
// ========== IMPORTS ==========
import { getCollection } from 'astro:content';
import ArticleLayout from '../../layouts/ArticleLayout.astro';
import Breadcrumb from '../../components/common/Breadcrumb.astro';
import PostsHeader from '../../components/docs/PostsHeader.astro';
import PostsGrid from '../../components/docs/PostsGrid.astro';
import Pagination from '../../components/common/Pagination/Pagination.astro';
import { getDocsPageData, POSTS_PER_PAGE } from '../../utils/docs-config';
import {
  validatePageNumber,
  shouldRedirectToFirstPage,
} from '../../components/common/Pagination/pagination';
import { generateBreadcrumbSchema } from '../../utils/breadcrumb-schema';
import docsSeoData from '../../data/seo/docs.json';
import '../../styles/pages/docs/docs-index.css';

// ========== STATIC PATH GENERATION ==========
export async function getStaticPaths() {
  const allPosts = await getCollection(
    'docs',
    ({ data }) =>
      data.status === 'published' &&
      data.publishedDate &&
      new Date(data.publishedDate) <= new Date()
  );

  const totalPages = Math.ceil(allPosts.length / POSTS_PER_PAGE);

  return Array.from({ length: totalPages }, (_, i) => ({
    params: { page: (i + 1).toString() },
    props: { totalPosts: allPosts.length, totalPages },
  }));
}

// ========== PAGE PARAMETERS & VALIDATION ==========
const { page } = Astro.params;
const { totalPosts, totalPages } = Astro.props;
const currentPage = validatePageNumber(page);

if (currentPage === 1) return Astro.redirect('/docs', 301);
if (shouldRedirectToFirstPage(currentPage, totalPages)) {
  return Astro.redirect(`/docs/page-${totalPages}`, 301);
}

// ========== GET PAGE DATA ==========
const { transformedPosts, seoConfig, structuredData } =
  await getDocsPageData(currentPage);

// ========== SEO DATA ==========
// SEOデータはJSONファイルから読み込み

// ========== PROCESSED SEO DATA ==========
const seoData = {
  ...docsSeoData.seoData,
  title: `${docsSeoData.seoData.title} - Page ${currentPage}`,
  description: `${docsSeoData.seoData.description} Halaman ${currentPage} dari dokumentasi lengkap.`,
  keywords: [
    ...docsSeoData.seoData.keywords,
    `halaman ${currentPage}`,
    `page ${currentPage}`,
  ],
  author: docsSeoData.seoData.author,
  pageType: docsSeoData.seoData.pageType as 'website' | 'article',
  lang: docsSeoData.seoData.lang as 'id' | 'ja',
};

// ========== STRUCTURED DATA ==========
const breadcrumbSchema = generateBreadcrumbSchema({
  items: [
    { title: 'Home', url: '/', isActive: false },
    { title: 'Documentation', url: '/docs', isActive: false },
    {
      title: `Page ${currentPage}`,
      url: `/docs/page-${currentPage}`,
      isActive: true,
    },
  ],
  siteUrl: String(Astro.site || 'https://gorakudo.org'),
});

const faqSchema = {
  ...docsSeoData.structuredData.faq,
  '@context': 'https://schema.org' as const,
  '@type': 'FAQPage' as const,
  mainEntity: docsSeoData.structuredData.faq.mainEntity.map(item => ({
    ...item,
    '@type': 'Question' as const,
    acceptedAnswer: { ...item.acceptedAnswer, '@type': 'Answer' as const },
  })),
};

const collectionPageSchema = {
  ...docsSeoData.structuredData.collectionPage,
  name: `${docsSeoData.structuredData.collectionPage.name} - Page ${currentPage}`,
  url: `/docs/page-${currentPage}`,
  mainEntity: {
    ...docsSeoData.structuredData.collectionPage.mainEntity,
    numberOfItems: transformedPosts.length,
    itemListElement: transformedPosts.map((post, index) => ({
      '@type': 'ListItem',
      position: index + 1,
      name: post.title,
      description: post.description,
      url: post.url,
      datePublished: post.publishedDate,
      author: { '@type': 'Organization', name: 'GoRakuDo Team' },
    })),
  },
};
---

<!-- ========== UNIFIED TEMPLATE (Same as Index) ========== -->
<ArticleLayout
  title={seoData.title}
  description={seoData.description}
  tags={seoData.keywords}
  lang={seoData.lang}
  author={seoData.author}
  publishedDate={new Date().toISOString()}
  currentPage={currentPage}
  totalPages={totalPages}
  baseUrl='/docs'
  breadcrumbSchema={breadcrumbSchema}
>
  <!-- Structured Data: CollectionPage -->
  <script
    type='application/ld+json'
    set:html={JSON.stringify(collectionPageSchema)}
  />

  <!-- Structured Data: FAQ -->
  <script type='application/ld+json' set:html={JSON.stringify(faqSchema)} />

  <!-- ページヘッダー -->
  <PostsHeader
    slot='articles-header'
    title={seoData.title}
    description={seoData.description}
  />

  <!-- ブレッドクラム -->
  <Breadcrumb
    slot='breadcrumb'
    currentPath={`/docs/page-${currentPage}`}
    showHome={true}
    showIcons={true}
    ariaLabel='Navigasi breadcrumb untuk halaman dokumentasi'
  />

  <!-- 検索セクション（将来の拡張用） -->
  <div slot='search'>
    <!-- Search component can be added here if needed -->
  </div>

  <!-- メインコンテンツ -->
  {
    totalPosts > 0 ? (
      <PostsGrid posts={transformedPosts} />
    ) : (
      <div class='empty-state'>
        <h2>記事が見つかりません</h2>
        <p>
          現在、公開されている記事がありません。しばらくしてから再度お試しください。
        </p>
      </div>
    )
  }

  <!-- ページネーション -->
  {
    totalPages > 1 && totalPosts > 0 && (
      <Pagination
        slot='pagination'
        currentPage={currentPage}
        totalPages={totalPages}
        baseUrl='/docs'
        showPageInfo={true}
      />
    )
  }
</ArticleLayout>

<!-- ========== SCRIPTS ========== -->
<script>
  // Performance monitoring
  const initPerformanceMonitoring = () => {
    if (!('performance' in window && 'PerformanceObserver' in window)) return;

    try {
      const observer = new PerformanceObserver(list => {
        list.getEntries().forEach(entry => {
          if (entry.entryType === 'largest-contentful-paint') {
            console.log('LCP:', entry.startTime);
          } else if (entry.entryType === 'first-input') {
            const fidEntry = entry as any;
            console.log('FID:', fidEntry.processingStart - entry.startTime);
          } else if (entry.entryType === 'layout-shift') {
            const clsEntry = entry as any;
            console.log('CLS:', clsEntry.value);
          }
        });
      });

      observer.observe({
        entryTypes: ['largest-contentful-paint', 'first-input', 'layout-shift'],
      });
    } catch (error) {
      console.log('Performance monitoring not available:', error);
    }
  };

  // Lazy loading
  const initLazyLoading = () => {
    if (!('IntersectionObserver' in window)) return;

    const imageObserver = new IntersectionObserver(
      (entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
              observer.unobserve(img);
            }
          }
        });
      },
      { rootMargin: '50px 0px', threshold: 0.01 }
    );

    document
      .querySelectorAll('img[data-src]')
      .forEach(img => imageObserver.observe(img));
  };

  // Service Worker
  const initServiceWorker = () => {
    if (!('serviceWorker' in navigator)) return;

    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register('/sw.js', { scope: '/', updateViaCache: 'none' })
        .then(registration => {
          console.log('SW registered: ', registration);

          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (
                  newWorker.state === 'installed' &&
                  navigator.serviceWorker.controller
                ) {
                  if (confirm('New content available! Refresh to update?')) {
                    window.location.reload();
                  }
                }
              });
            }
          });
        })
        .catch(registrationError => {
          console.log('SW registration failed: ', registrationError);
        });
    });
  };

  // Initialize all
  const init = () => {
    initPerformanceMonitoring();
    initLazyLoading();
    initServiceWorker();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
