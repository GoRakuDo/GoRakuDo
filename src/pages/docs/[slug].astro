---
import { getCollection, type CollectionEntry } from "astro:content"
import { statSync } from "fs"
import { join } from "path"
import UnifiedSEO from "../../components/UnifiedSEO.astro"
import Breadcrumb from "../../components/public-components/Breadcrumb.astro"
import Navbar from "../../components/public-components/Navbar.vue"
import PostLayout from "../../components/content/PostLayout.astro"
import {
  resolvePath,
  getCollectionInfo,
} from "../../utils/collections"

// Import post[slug]-specific styles with Tailwind v4 optimization
import "../../styles/docs/[slug].css"

// Generate static paths for all docs posts
export async function getStaticPaths() {
  const posts = await getCollection("docs")

  return posts.map((post) => ({
    params: { slug: post.slug },
    props: { post },
  }))
}

// Get the post from props with explicit type casting
const { post } = Astro.props as { post: CollectionEntry<"docs"> }

// Smart error handling - redirect to docs listing if post not found
if (!post) {
  return Astro.redirect("/docs?error=post-not-found")
}

// Dynamic content path resolution for SEO
const resolvedPath = { path: resolvePath("docs", post.slug) }
const collectionMetadata = getCollectionInfo("docs")

// ファイルシステムから自動的に作成日・更新日を取得
function getFileDates(slug: string) {
  try {
    const filePath = join(process.cwd(), 'src/content/docs', `${slug}.md`)
    const stats = statSync(filePath)
    
    return {
      createdDate: stats.birthtime.toISOString(),
      modifiedDate: stats.mtime.toISOString()
    }
  } catch (error) {
    console.warn(`⚠️ Could not get file dates for ${slug}:`, error)
    return {
      createdDate: new Date().toISOString(),
      modifiedDate: new Date().toISOString()
    }
  }
}

// ファイルの作成日・更新日を自動取得
const fileDates = getFileDates(post.slug)

// Dynamic SEO data based on document content (フロントマター完全対応 + 自動日付)
const seoData = {
  title: post.data.title || `Documentation - ${post.slug}`,
  description: post.data.description || `Learn about ${post.slug} in GoRakuDo documentation`,
  keywords: post.data.tags || ["documentation", post.slug, "guide"], // ✅ tagsフィールドを使用
  articleType: "guide",
  learningStage: post.data.difficulty || "intermediate", // ✅ difficultyフィールドを使用
  searchIntent: "informational",
  // フロントマターの日付があれば使用、なければファイルシステムの日付を使用
  publishedDate: post.data.publishedDate || fileDates.createdDate,
  modifiedDate: post.data.modifiedDate || fileDates.modifiedDate,
  isDraft: post.data.isDraft || false
}

// Prepare post data for script section with dynamic path resolution
const postData = {
  title: post.data.title,
  description: post.data.description,
  publishedDate: post.data.publishedDate,
  author: post.data.author,
  readTime: post.data.readTime,
  difficulty: post.data.difficulty,
  body: post.body,
  slug: post.slug,
  resolvedPath: resolvedPath.path,
  collectionMetadata: {
    displayName: collectionMetadata.displayName,
    icon: collectionMetadata.icon,
    basePath: collectionMetadata.basePath,
  },
}

// Generate optimized recommendations for this post (checks for existing metadata first)
let relatedContent: any = null
let internalLinks: any = null
let enhancedContent: string = post.body

// Post processing removed - functionality no longer needed
relatedContent = []
internalLinks = []
enhancedContent = post.body

// Metadata processing removed
console.log(`📝 Post "${post.slug}" processed without AI features`)
---

<html lang="ja">
  <head>
    <!-- UnifiedSEO - シンプルなAstroネイティブ実装 -->
    <UnifiedSEO
      title={seoData.title}
      description={seoData.description}
      keywords={seoData.keywords}
      pageType="article"
      author={post.data.author || "GoRakuDo Team"}
      publishedDate={seoData.publishedDate}
      modifiedDate={seoData.modifiedDate}
      noindex={seoData.isDraft}
    />

    <!-- Preload critical resources for better performance -->
    <link
      rel="preload"
      href="https://cdn.jsdelivr.net/npm/marked/marked.min.js"
      as="script"
    />
    <script src="/core/post-script.js" is:inline></script>

    <!-- Fonts with display=swap for better performance -->
    <link
      href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&family=Inter:wght@300;400;500;600;700&family=Lora:wght@400;600&family=Cedarville+Cursive&display=swap"
      rel="stylesheet"
    />

    <!-- Core: Always load marked for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </head>

  <body>
    <!-- Navigation -->
    <Navbar client:visible />

    <!-- Decorative Background Elements -->
    <canvas id="waveCanvas" class="wave-canvas" aria-hidden="true"></canvas>

    <div class="stars" aria-hidden="true">
      <div class="star" style="top: 10%; left: 20%; animation-delay: 0s;"></div>
      <div class="star" style="top: 20%; right: 20%; animation-delay: 1s;"></div>
      <div class="star" style="top: 30%; left: 80%; animation-delay: 2s;"></div>
      <div class="star" style="bottom: 30%; left: 10%; animation-delay: 1.5s;"></div>
      <div class="star" style="bottom: 20%; right: 30%; animation-delay: 0.5s;"></div>
      <div class="star" style="top: 60%; left: 15%; animation-delay: 2.5s;"></div>
      <div class="star" style="top: 80%; right: 20%; animation-delay: 1.8s;"></div>
      <div class="star" style="bottom: 40%; right: 60%; animation-delay: 0.8s;"></div>
    </div>

    <!-- Use the new PostLayout component -->
    <PostLayout {post} {collectionMetadata}>
      <Breadcrumb 
        post={post} 
        slot="breadcrumb" 
      />
      <!-- Article content will be rendered here by the layout -->
    </PostLayout>

    <!-- Scripts Section - Organized and Optimized -->
    <script is:inline src="/core/post-script.js"></script>

    <!-- Main Application Script -->
    <script define:vars={{ postData, enhancedContent }}>
      // Share functionality with dynamic path support
      function sharePost() {
        const shareUrl = postData?.resolvedPath
          ? `${window.location.origin}${postData.resolvedPath}`
          : window.location.href

        if (navigator.share) {
          navigator.share({
            title: postData?.title || "GoRakuDo Post",
            text: postData?.description || "Check out this post from GoRakuDo",
            url: shareUrl,
          })
        } else {
          // Fallback: copy to clipboard
          navigator.clipboard.writeText(shareUrl).then(() => {
            alert("Link berhasil disalin ke clipboard!")
          })
        }
      }

      // Make sharePost globally accessible for onclick handlers
      window.sharePost = sharePost;

      // Reading progress indicator
      function addReadingProgress() {
        const progressBar = document.createElement("div")
        progressBar.className = "reading-progress"
        progressBar.setAttribute("role", "progressbar")
        progressBar.setAttribute("aria-label", "Reading progress")
        progressBar.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 0%;
          height: 3px;
          background: linear-gradient(90deg, #8b5dff, #7b4def);
          z-index: 1000;
          transition: width 0.1s ease;
        `
        document.body.appendChild(progressBar)

        window.addEventListener("scroll", () => {
          const scrollTop = window.pageYOffset
          const docHeight = document.body.scrollHeight - window.innerHeight
          const scrollPercent = (scrollTop / docHeight) * 100
          progressBar.style.width = scrollPercent + "%"
          progressBar.setAttribute("aria-valuenow", Math.round(scrollPercent))
        })
      }

      // Render post content
      function renderPostContent() {
        if (!postData) return

        const content = window.enhancedContent || postData.body
        const postContent = document.getElementById("postContent")

        if (!postContent) return

        // Configure marked for markdown rendering
        marked.setOptions({
          highlight: function (code, lang) {
            return `<pre><code class="language-${lang}">${code}</code></pre>`
          },
          breaks: true,
          gfm: true,
        })

        // Render content
        const renderedHTML = marked.parse(content)
        postContent.innerHTML = renderedHTML
      }

      // Initialize when DOM is ready
      document.addEventListener("DOMContentLoaded", function () {
        renderPostContent()
        addReadingProgress()
      })
    </script>
  </body>
</html>
