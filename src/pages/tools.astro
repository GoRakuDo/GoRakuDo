---
import UnifiedSEO from "../components/UnifiedSEO.astro"
import BaseLayout from "../layouts/BaseLayout.astro"
import Navbar from "../components/public-components/Navbar.vue"

// Import CSS
import "../styles/global.css"
import "../styles/tools/tools.css"

// Import images
import homepageOgImage from "../assets/images/Logo Discord.png"

// SEO data - Astro„Éç„Ç§„ÉÜ„Ç£„Éñ„Ç¢„Éó„É≠„Éº„ÉÅÔºàË®≠ÂÆö„Éï„Ç°„Ç§„É´‰∏çË¶ÅÔºâ
const seoData = {
  title: "Alat Belajar Bahasa Jepang - GoRakuDo",
  description: "Alat bantu pembelajaran bahasa Jepang yang efektif untuk memperoleh kemahiran berbahasa Jepang. Utilitas pembelajaran terbaik di Indonesia",
  keywords: ["alat", "bantu", "pembelajaran", "bahasa", "jepang", "belajar", "efektif", "kemahiran", "utilitas", "learning"],
  pageType: "website" as const
}

// Tools data - structured for easy management and expansion
const tools = [
  {
    id: "anki",
    name: "Anki",
    description:
      "Sistem flashcard dengan Spaced Repetition System (SRS) untuk menghafal kosakata dan kanji secara efektif.",
    icon: "üìö",
    color: "var(--clr-accent)",
    link: "/tools/anki",
    difficulty: "intermediate",
    category: "flashcard",
    featured: true,
    interactiveElements: {
      hasHoverEffect: true,
      hasClickAction: true,
      animationType: "scale",
    },
  },
  {
    id: "yomitan",
    name: "Yomichan",
    description:
      "Browser extension untuk membaca bahasa Jepang dengan hover dictionary dan furigana generation.",
    icon: "üîç",
    color: "var(--clr-accent-dark)",
    link: "/tools/yomitan",
    difficulty: "beginner",
    category: "reading",
    featured: true,
    interactiveElements: {
      hasHoverEffect: true,
      hasClickAction: true,
      animationType: "slide",
    },
  },
  {
    id: "migaku",
    name: "Migaku",
    description:
      "Suite tools untuk immersion learning termasuk browser extension dan Anki integration.",
    icon: "üéØ",
    color: "var(--clr-accent-glow-strong)",
    link: "/tools/migaku",
    difficulty: "intermediate",
    category: "suite",
    featured: false,
    status: "available",
    priority: "medium",
    estimatedCompletion: "Available Now",
    tags: ["suite", "immersion", "integration"],
    interactiveElements: {
      hasHoverEffect: true,
      hasClickAction: true,
      animationType: "scale",
    },
  },
]
---

<html lang="ja">
  <head>
    <!-- UnifiedSEO - „Ç∑„É≥„Éó„É´„Å™Astro„Éç„Ç§„ÉÜ„Ç£„ÉñÂÆüË£Ö -->
    <UnifiedSEO
      title={seoData.title}
      description={seoData.description}
      keywords={seoData.keywords}
      pageType={seoData.pageType}
    />
    <!-- Prefetch critical resources -->
    <link fetchpriority="low" rel="prefetch" href="/docs" />
  </head>
  <body>
    <!-- Navigation -->
    <Navbar client:visible />

    <!-- Background Animations -->
    <canvas id="waveCanvas" class="wave-canvas" aria-hidden="true"></canvas>
    <div class="stars" id="stars" aria-hidden="true"></div>

    <!-- Main Content -->
    <main
      class="main-content min-h-screen tools-layout-optimized"
      role="main"
      transition:name="main-content">
      <!-- Hero Section -->
      <section
        class="tools-section loading py-16 sm:py-20 lg:py-24 xl:py-32"
        aria-labelledby="tools-title"
        transition:name="tools-hero">
        <div class="container px-4 sm:px-6 lg:px-8">
          <div class="max-w-4xl mx-auto text-center">
            <h1
              class="tools-hero-title mb-4 sm:mb-6"
              id="tools-hero-title"
              transition:name="tools-hero-title">
              Tools Immersion
            </h1>
            <p
              class="tools-hero-description text-lg sm:text-xl lg:text-2xl leading-relaxed max-w-3xl mx-auto">
              Kumpulan tools dan aplikasi terbaik yang telah terbukti efektif untuk
              pembelajaran bahasa Jepang dengan metode immersion.
            </p>
          </div>
        </div>
      </section>

      <!-- Tools Grid Section -->
      <section
        class="npmnpm loading py-12 sm:py-16 lg:py-20 scroll-reveal"
        aria-labelledby="tools-title"
        transition:name="tools-section"
        data-lazy>
        <div class="container px-4 sm:px-6 lg:px-8">
          <div class="tools-header mb-12 sm:mb-16 lg:mb-20">
            <div class="max-w-3xl mx-auto text-center">
              <h1 class="tools-title mb-4 sm:mb-6" id="tools-title">Tools & Aplikasi</h1>
              <p class="tools-description text-base sm:text-lg leading-relaxed">
                Pilih tool yang sesuai dengan tahap pembelajaran dan kebutuhan Anda.
              </p>
            </div>
          </div>

          <!-- Semantic List for Accessibility -->
          <div
            class="tools-grid max-w-7xl mx-auto grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 sm:gap-8 lg:gap-10 tools-migration-enabled">
            {
              tools.map((tool) => (
                <div class="tool-grid-item">
                  <a
                    href={tool.link}
                    class="tool-card group hover:scale-[1.02] transition-all duration-300 ease-out tools-interactive-optimized"
                    aria-labelledby={`tool-name-${tool.id}`}
                    aria-describedby={`tool-desc-${tool.id}`}>
                    <article class="h-full flex flex-col">
                      <header class="tool-card-header flex items-start justify-between gap-4 mb-6">
                        <div
                          class={`tool-icon tool-icon-${tool.id} flex-shrink-0 w-12 h-12 sm:w-14 sm:h-14 flex items-center justify-center rounded-lg text-xl sm:text-2xl`}>
                          {tool.icon}
                        </div>
                        <div class="tool-meta flex flex-col items-end gap-2 flex-shrink-0">
                          <span class="tool-difficulty text-xs font-medium px-2 py-1 rounded-full border">
                            {tool.difficulty === "beginner"
                              ? "Pemula"
                              : tool.difficulty === "intermediate"
                                ? "Menengah"
                                : "Lanjutan"}
                          </span>
                          <span class="tool-category text-xs font-medium px-2 py-1 rounded-full border">
                            {tool.category}
                          </span>
                        </div>
                      </header>
                      <div class="tool-card-body flex-grow mb-6">
                        <h3
                          class="tool-name text-lg sm:text-xl font-semibold mb-3 leading-tight"
                          id={`tool-name-${tool.id}`}>
                          {tool.name}
                        </h3>
                        <p
                          class="tool-description-card text-sm sm:text-base leading-relaxed opacity-80"
                          id={`tool-desc-${tool.id}`}>
                          {tool.description}
                        </p>
                      </div>
                      <footer class="tool-card-footer flex items-center justify-between pt-4 border-t border-white/10">
                        <span class="tool-cta-text text-sm font-medium">
                          Lihat Panduan
                        </span>
                        <svg
                          class="tool-arrow w-4 h-4 group-hover:translate-x-1 transition-transform duration-200"
                          width="16"
                          height="16"
                          viewBox="0 0 24 24"
                          fill="none"
                          stroke="currentColor"
                          stroke-width="2.5">
                          <path d="M5 12h14M12 5l7 7-7 7" />
                        </svg>
                      </footer>
                    </article>
                  </a>
                </div>
              ))
            }
          </div>
        </div>
      </section>
    </main>

    <script>
      // Wave and Stars animation scripts remain unchanged and are omitted for brevity.
      // They are assumed to be present here as in the original file.

      // üåä DOCS PAGE WAVE ANIMATION INITIALIZATION
      // Google Engineering Team 2025: Performance-optimized wave animation for docs page

      let waveAnimation: { cleanup: () => void } | null = null
      let starsContainer: HTMLElement | null = null

      // Initialize wave animation for docs page
      function initializeDocsWaveAnimation(): (() => void) | undefined {
        console.log("üåä Initializing docs page wave animation...")

        const canvas = document.getElementById("waveCanvas")
        if (!canvas) {
          console.warn("Wave canvas not found for docs page")
          return undefined
        }

        const ctx = (canvas as HTMLCanvasElement)?.getContext("2d")
        if (!ctx) {
          console.warn("Canvas context not available for docs page")
          return undefined
        }

        let animationId: number | null = null
        let time = 0

        // Docs-specific wave configuration (optimized for content pages)
        const waves = [
          {
            amplitude: 40,
            frequency: 0.01,
            speed: 0.02,
            offset: 0,
            color: "rgba(139, 93, 255, 0.08)",
            y: 0.7,
            yPos: 0, // Will be set in resizeCanvas
          },
          {
            amplitude: 60,
            frequency: 0.008,
            speed: -0.015,
            offset: Math.PI / 3,
            color: "rgba(139, 93, 255, 0.06)",
            y: 0.75,
            yPos: 0, // Will be set in resizeCanvas
          },
          {
            amplitude: 35,
            frequency: 0.012,
            speed: 0.025,
            offset: Math.PI / 2,
            color: "rgba(139, 93, 255, 0.04)",
            y: 0.8,
            yPos: 0, // Will be set in resizeCanvas
          },
          {
            amplitude: 45,
            frequency: 0.009,
            speed: -0.018,
            offset: Math.PI,
            color: "rgba(139, 93, 255, 0.03)",
            y: 0.85,
            yPos: 0, // Will be set in resizeCanvas
          },
        ]

        function resizeCanvas() {
          const width = window.innerWidth
          const height = window.innerHeight
          ;(canvas as HTMLCanvasElement).width = width
          ;(canvas as HTMLCanvasElement).height = height

          // Update wave y positions based on new height
          waves.forEach((wave) => {
            wave.yPos = height * wave.y
          })
        }

        function animate() {
          if (!ctx) return


          ctx.clearRect(
            0,
            0,
            (canvas as HTMLCanvasElement).width,
            (canvas as HTMLCanvasElement).height
          )

          // Create gradient background (docs-specific)
          const gradient = ctx.createLinearGradient(
            0,
            0,
            0,
            (canvas as HTMLCanvasElement).height
          )
          gradient.addColorStop(0, "rgba(10, 10, 10, 1)")
          gradient.addColorStop(0.6, "rgba(10, 10, 10, 0.98)")
          gradient.addColorStop(1, "rgba(139, 93, 255, 0.015)")
          ctx.fillStyle = gradient
          ctx.fillRect(
            0,
            0,
            (canvas as HTMLCanvasElement).width,
            (canvas as HTMLCanvasElement).height
          )

          // ENHANCED: Adaptive wave rendering based on device performance
          const screenWidth = window.innerWidth
          let waveStep = 2 // Default step size

          // Reduce wave detail on smaller screens or low-end devices
          if (screenWidth < 768) {
            waveStep = 4 // Reduce detail on mobile
          } else if (screenWidth < 1024) {
            waveStep = 3 // Reduce detail on tablets
          }

          // Draw waves with adaptive quality
          waves.forEach((wave) => {
            ctx.beginPath()

            // Create wave path with adaptive step size
            for (
              let x = 0;
              x <= (canvas as HTMLCanvasElement).width + 10;
              x += waveStep
            ) {
              const y =
                (wave.yPos as number) +
                Math.sin(x * wave.frequency + time * wave.speed + wave.offset) *
                  wave.amplitude

              if (x === 0) {
                ctx.moveTo(x, y)
              } else {
                ctx.lineTo(x, y)
              }
            }

            // Close the path to create filled area
            ctx.lineTo(
              (canvas as HTMLCanvasElement).width,
              (canvas as HTMLCanvasElement).height
            )
            ctx.lineTo(0, (canvas as HTMLCanvasElement).height)
            ctx.closePath()

            ctx.fillStyle = wave.color
            ctx.fill()

            // Add subtle stroke for more definition (skip on low-end devices)
            if (screenWidth >= 768) {
              ctx.strokeStyle = "rgba(139, 93, 255, 0.08)"
              ctx.lineWidth = 0.5
              ctx.stroke()
            }
          })

          // ENHANCED: Adaptive time increment based on performance
          const timeIncrement = screenWidth < 768 ? 0.3 : 0.5
          time += timeIncrement

          animationId = requestAnimationFrame(animate)
        }

        // Initialize
        resizeCanvas()
        animate()

        // Handle window resize
        const handleResize = () => {
          resizeCanvas()
        }
        window.addEventListener("resize", handleResize)

        // Return cleanup function
        return () => {
          if (animationId) {
            cancelAnimationFrame(animationId)
          }
          window.removeEventListener("resize", handleResize)
        }
      }

      // Initialize wave animation when DOM is ready
      document.addEventListener("DOMContentLoaded", function () {
        try {
          const cleanup = initializeDocsWaveAnimation()
          waveAnimation = {
            cleanup: cleanup || (() => {}),
          }


          console.log("‚úÖ Docs page wave animation initialized successfully")
        } catch (error) {
          console.error("Error initializing docs page wave animation:", error)
        }
      })

      // Dynamic import for animation modules with comprehensive error handling
      Promise.all([import("../scripts/ui/background-animations/stars-animation.js")])
        .then(([starsModule]) => {
          console.log("üé¨ Stars animation module loaded successfully")

          // Initialize stars animation only
          const starsAnimation = starsModule.initStarsAnimation({
            enabled: true,
            count: 8,
            animationDuration: "4s",
            opacity: 0.6,
            containerClass: "stars",
            starClass: "star",
            containerId: "stars",
            useExistingContainer: true,
            createContainer: false,
            containerSelector: ".stars",
            accessibility: {
              respectReducedMotion: false,
              announceChanges: false,
              screenReaderFriendly: true,
              highContrastSupport: true,
              forceEnable: true,
            },
          })

          // Start animations when page loads
          window.addEventListener("load", () => {
            try {
              // Initialize stars animation with existing container
              starsAnimation.init("stars")
              console.log("‚ú® Stars animation initialized successfully")

              // Debug: Check if stars were created
              setTimeout(() => {
                const stars = document.querySelectorAll(".star")
                console.log(`üîç Debug: Found ${stars.length} stars in DOM`)
                if (stars.length > 0) {
                  console.log("‚úÖ Stars are visible in DOM")
                } else {
                  console.log("‚ö†Ô∏è No stars found in DOM - checking container")
                  const container = document.querySelector(".stars")
                  console.log("Container:", container)
                }
              }, 500)

              // Add loaded class to prevent popup effect
              setTimeout(() => {
                const starsContainer = document.querySelector(".stars")
                if (starsContainer) {
                  starsContainer.classList.add("loaded")
                }
              }, 100)

              // Trigger hero animation after animations are ready
              setTimeout(() => {
                const heroContent = document.querySelector("#hero-content")
                if (heroContent) {
                  heroContent.classList.remove(
                    "opacity-0",
                    "translate-y-16",
                    "scale-80",
                    "blur-md"
                  )
                  console.log("‚ú® Hero content revealed smoothly")
                }
              }, 200) // Coordinate with hero component timing
            } catch (error) {
              console.error("‚ùå Animation initialization error:", error)
            }
          })
        })
        .catch((error) => {
          console.log("‚ö†Ô∏è Animation modules failed to load:", error.message)
          // Fallback: continue with existing inline animations
          console.log("üîÑ Falling back to existing inline animations")
        })

      // Cleanup on page unload
      window.addEventListener("beforeunload", function () {
        if (waveAnimation) {
          waveAnimation.cleanup()
        }
      })

      // ========== ENHANCED TRANSITIONS & LOADING STATES ==========
      // Performance-optimized animations and loading states for better UX

      // Enhanced loading state management
      document.addEventListener("DOMContentLoaded", function () {
        // Apply page load animations with performance monitoring
        const mainContent = document.querySelector(".main-content")
        if (mainContent) {
          mainContent.classList.add("page-load-fade-in")
        }

        // Apply staggered animations to tool cards
        const toolCards = document.querySelectorAll(".tool-card")
        toolCards.forEach((card, index) => {
          ;(card as HTMLElement).style.setProperty("--stagger-delay", index.toString())
          card.classList.add("stagger-animation")
        })

        console.log("‚úÖ Enhanced loading states applied")
      })

      // Intersection Observer for scroll reveals
      const scrollRevealObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add("in-view")
              scrollRevealObserver.unobserve(entry.target)
            }
          })
        },
        {
          threshold: 0.1,
          rootMargin: "50px",
        }
      )

      // Apply scroll reveals to sections
      document.addEventListener("DOMContentLoaded", function () {
        const sections = document.querySelectorAll(
          "section.scroll-reveal, .scroll-reveal"
        )
        sections.forEach((section) => {
          section.classList.add("scroll-reveal-intersection")
          scrollRevealObserver.observe(section)
        })
      })

      // Enhanced micro-interactions for better feedback
      document.addEventListener("DOMContentLoaded", function () {
        // Add micro-interactions ONLY to tools page elements (avoid navbar conflicts)
        const toolsPageElements = document.querySelectorAll(`
          .tool-card,
          .tools-section a,
          .tools-section button,
          .main-content a:not([href="/"]),
          .main-content button:not(.get-started-btn):not(.mobile-menu-btn)
        `)
        toolsPageElements.forEach((element) => {
          element.classList.add("micro-interaction-scale", "focus-enhanced")
        })

        // Enhanced loading states for lazy content
        const lazyElements = document.querySelectorAll("[data-lazy]")
        const lazyObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                entry.target.classList.add("loaded")

                // Remove loading pulse if present
                entry.target.classList.remove("loading-pulse")

                lazyObserver.unobserve(entry.target)
              }
            })
          },
          { threshold: 0.1, rootMargin: "50px" }
        )

        lazyElements.forEach((el) => {
          el.classList.add("loading-pulse") // Add loading pulse while loading
          lazyObserver.observe(el)
        })

        console.log("‚úÖ Enhanced micro-interactions and scroll reveals initialized")
      })

      // Performance monitoring for animations
      window.addEventListener("load", function () {
        // Monitor animation performance
        let animationFrameCount = 0
        let lastAnimationTime = performance.now()

        function monitorAnimationPerformance() {
          animationFrameCount++
          const currentTime = performance.now()
          const deltaTime = currentTime - lastAnimationTime

          // Log animation performance every 5 seconds
          if (animationFrameCount % 300 === 0) {
            const fps = 1000 / deltaTime
            console.log(
              `üé¨ Animation Performance: ${fps.toFixed(1)}fps (Frame ${animationFrameCount})`
            )
          }

          lastAnimationTime = currentTime
          requestAnimationFrame(monitorAnimationPerformance)
        }

        requestAnimationFrame(monitorAnimationPerformance)
      })

      // ========== CROSS-BROWSER COMPATIBILITY & SECURITY ==========
      // Enhanced browser support and security measures

      // Browser capability detection and security validation
      document.addEventListener("DOMContentLoaded", function () {
        // Security: Sanitize and validate browser environment
        const securityCheck = {
          isSecureContext: window.isSecureContext,
          hasCSP:
            document.querySelector('meta[http-equiv="Content-Security-Policy"]') !== null,
          trustedOrigin:
            window.location.origin === "https://gorakudo.org" ||
            window.location.hostname === "localhost",
        }

        console.log("üîí Security Context:", securityCheck)

        // Enhanced browser detection
        const browserDetect = {
          userAgent: navigator.userAgent,
          isChrome:
            /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor),
          isFirefox: /Firefox/.test(navigator.userAgent),
          isSafari:
            /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent),
          isEdge: /Edg/.test(navigator.userAgent),
          isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ),
          supportsGrid: CSS.supports("display", "grid"),
          supportsFlex: CSS.supports("display", "flex"),
          supportsClamp: CSS.supports("width", "clamp(1px, 2px, 3px)"),
          supportsIntersectionObserver: "IntersectionObserver" in window,
          supportsRequestAnimationFrame: "requestAnimationFrame" in window,
          supportsPerformanceObserver: "PerformanceObserver" in window,
        }

        console.log("üåê Browser Capabilities:", browserDetect)

        // Apply browser-specific optimizations
        const html = document.documentElement

        if (browserDetect.isChrome || browserDetect.isEdge) {
          html.classList.add("chromium-optimized")
        } else if (browserDetect.isSafari) {
          html.classList.add("safari-optimized")
        } else if (browserDetect.isFirefox) {
          html.classList.add("firefox-optimized")
        }

        // Progressive enhancement based on capabilities
        if (!browserDetect.supportsIntersectionObserver) {
          console.log("‚ö†Ô∏è IntersectionObserver not supported, using fallback")
          // Fallback: reveal all scroll-reveal elements immediately
          document.querySelectorAll(".scroll-reveal-intersection").forEach((el) => {
            el.classList.add("in-view")
          })
        }

        if (!browserDetect.supportsRequestAnimationFrame) {
          console.log("‚ö†Ô∏è requestAnimationFrame not supported, using setTimeout fallback")
          // Fallback for animations using setTimeout
        }

        if (!browserDetect.supportsGrid) {
          console.log("‚ö†Ô∏è CSS Grid not supported, applying fallback")
          // Apply grid fallbacks
          document.querySelectorAll(".tools-grid").forEach((grid) => {
            grid.classList.add("browser-compat-grid")
          })
        }

        if (!browserDetect.supportsClamp) {
          console.log("‚ö†Ô∏è clamp() not supported, fallback applied")
          // clamp() fallbacks are handled in CSS
        }

        // Security: Sanitize dynamic content
        const sanitizeClassName = (className) => {
          // Only allow predefined safe class names
          const safeClasses = [
            "loading",
            "loaded",
            "in-view",
            "page-load-fade-in",
            "stagger-animation",
            "scroll-reveal-intersection",
            "micro-interaction-scale",
            "focus-enhanced",
            "loading-pulse",
          ]
          return safeClasses.includes(className) ? className : ""
        }

        // Enhanced accessibility: respect user's motion preferences
        const prefersReducedMotion = window.matchMedia(
          "(prefers-reduced-motion: reduce)"
        ).matches
        if (prefersReducedMotion) {
          console.log("‚ôø Reduced motion preference detected, animations simplified")
          // Disable heavy animations
          document.documentElement.style.setProperty("--animation-duration", "0.01ms")
        }

        // Security audit logging
        console.log("üîç Security Audit Complete:", {
          secureContext: securityCheck.isSecureContext,
          trustedOrigin: securityCheck.trustedOrigin,
          browserSupported: Object.values(browserDetect).filter(Boolean).length,
          totalCapabilities: Object.keys(browserDetect).length,
        })
      })

      // Animation Modules Integration
      window.addEventListener("load", async () => {
        try {
          // Import animation modules
          const [starsModule] = await Promise.all([
            import("../scripts/ui/background-animations/stars-animation.js"),
          ])

          // Initialize stars animation with performance monitoring
          const starsAnimation = starsModule.initStarsAnimation({
            enabled: true,
            count: 8,
            animationDuration: "4s",
            opacity: 0.6,
            containerClass: "stars",
            starClass: "star",
            containerId: "stars",
            useExistingContainer: true,
            createContainer: false,
            containerSelector: ".stars",
            performance: {
              targetFPS: 60,
              memoryThreshold: 100 * 1024 * 1024, // 100MB
              autoReduceComplexity: true,
              reduceThreshold: 30,
            },
            accessibility: {
              respectReducedMotion: true, // Enable for better performance monitoring
              announceChanges: false,
              screenReaderFriendly: true,
              highContrastSupport: true,
              forceEnable: false, // Allow performance monitoring to control
            },
          })

          // Initialize the animation with performance optimizations
          starsAnimation.init("stars")

          // ENHANCED: Monitor stars animation performance
          ;(window as any).starsAnimationInstance = starsAnimation

          // Add smooth fade-in for stars
          setTimeout(() => {
            const starsContainer = document.querySelector(".stars")
            if (starsContainer) {
              starsContainer.classList.add("loaded")
            }
          }, 100)

          console.log("‚úÖ Tools page animations initialized successfully")

          // Debug: Check if stars were created
          setTimeout(() => {
            const stars = document.querySelectorAll(".star")
            console.log(`üîç Debug: Found ${stars.length} stars in DOM`)
            if (stars.length > 0) {
              console.log("‚úÖ Stars are visible in DOM")
              console.log("First star element:", stars[0])
            } else {
              console.log("‚ö†Ô∏è No stars found in DOM - checking container")
              const container = document.querySelector(".stars")
              console.log("Container:", container)
              console.log("Container HTML:", container?.innerHTML)
            }
          }, 500)
        } catch (error) {
          console.error("‚ùå Error initializing tools page animations:", error)
        }
      })

      // Enhanced Intersection Observer for lazy loading (unchanged)
      const lazyElements = document.querySelectorAll("[data-lazy]")
      const lazyObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add("loaded")
              lazyObserver.unobserve(entry.target)
            }
          })
        },
        { threshold: 0.1, rootMargin: "50px" }
      )
      lazyElements.forEach((el) => lazyObserver.observe(el))

      // REDESIGNED tool card interaction system
      document.addEventListener("DOMContentLoaded", () => {
        const toolCards = document.querySelectorAll(".tool-card")

        toolCards.forEach((card) => {
          // Click/Tap feedback for all devices
          card.addEventListener("click", (e) => {
            e.preventDefault()

            // Add visual feedback
            card.classList.add("is-interacting")

            // Navigate after animation
            setTimeout(() => {
              card.classList.remove("is-interacting")
              window.location.href = (card as HTMLAnchorElement).href
            }, 150)
          })

          // Keyboard navigation support
          card.addEventListener("keydown", (e) => {
            if (
              (e as KeyboardEvent).key === " " ||
              (e as KeyboardEvent).key === "Enter"
            ) {
              e.preventDefault()
              ;(card as HTMLAnchorElement).click()
            }
          })
        })

        // Preload critical resources (updated for new tool routes)
        const preloadLinks = [
          "/tools/anki",
          "/tools/yomitan",
          "/tools/migaku",
          "/docs/language-reactor-guide",
        ]
        preloadLinks.forEach((link) => {
          const preload = document.createElement("link")
          preload.rel = "prefetch"
          preload.href = link
          preload.setAttribute("fetchpriority", "low")
          document.head.appendChild(preload)
        })
      })

      // ========== ANIMATION PERFORMANCE MONITORING ==========
      // Device-specific animation optimization and performance monitoring
      // Implements PERF-001: Animation Performance Degradation mitigation

      // Enhanced performance monitoring for interactive features
      const performanceMonitor = {
        startTime: performance.now(),
        animationObserver: null as PerformanceObserver | null,

        init() {
          console.log("üéØ LCP:", this.getLCP().toFixed(2), "ms")
          console.log("‚ö° FID:", this.getFID().toFixed(2), "ms")
          console.log("üìê CLS:", this.getCLSValue().toFixed(4))
          console.log("üé® FCP:", this.getFCP().toFixed(2), "ms")

          // Custom animation performance logging
          this.animationObserver = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
              if (entry.entryType === "measure") {
                console.log(
                  `üé¨ Animation: ${entry.name} - ${entry.duration.toFixed(2)}ms`
                )
              }
            }
          })
          this.animationObserver.observe({ entryTypes: ["measure"] })
        },

        getLCP(): number {
          const entries = performance.getEntriesByType("largest-contentful-paint")
          return entries.length > 0 ? entries[0].startTime : 0
        },

        getFID(): number {
          const entries = performance.getEntriesByType("first-input")
          return entries.length > 0
            ? (entries[0] as any).processingStart - entries[0].startTime
            : 0
        },

        getCLSValue(): number {
          const entries = performance.getEntriesByType("layout-shift")
          return entries.reduce((sum, entry: any) => sum + entry.value, 0)
        },

        getFCP(): number {
          const entries = performance.getEntriesByType("paint")
          const fcp = entries.find((entry) => entry.name === "first-contentful-paint")
          return fcp ? fcp.startTime : 0
        },
      }

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        if (performanceMonitor.animationObserver) {
          performanceMonitor.animationObserver.disconnect()
        }
      })
    </script>
  </body>
</html>
